<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>React 使用 Effect 同外部系统协作 - jblogs</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="jblogs"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="jblogs"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="有些组件需要与外部系统同步。例如，可能希望根据 React state 控制非 React 组件、设置服务器连接或在组件出现在屏幕上时发送分析日志。使用 Effects 会在组件渲染后运行一些代码，以便可以将组件与 React 之外的某些系统同步。"><meta property="og:type" content="blog"><meta property="og:title" content="React 使用 Effect 同外部系统协作"><meta property="og:url" content="https://jblogs.tech/2024/03/framworks/front_framworks/react/effect-sync-with-external-sys/"><meta property="og:site_name" content="jblogs"><meta property="og:description" content="有些组件需要与外部系统同步。例如，可能希望根据 React state 控制非 React 组件、设置服务器连接或在组件出现在屏幕上时发送分析日志。使用 Effects 会在组件渲染后运行一些代码，以便可以将组件与 React 之外的某些系统同步。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jblogs.tech/images/covers/react/react-logo.jpg"><meta property="article:published_time" content="2024-03-24T06:13:34.000Z"><meta property="article:modified_time" content="2024-03-24T10:16:02.888Z"><meta property="article:author" content="Jeill"><meta property="article:tag" content="笔记"><meta property="article:tag" content="React"><meta property="article:tag" content="前端"><meta property="article:tag" content="框架"><meta property="article:tag" content="前端框架"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jblogs.tech/images/covers/react/react-logo.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jblogs.tech/2024/03/framworks/front_framworks/react/effect-sync-with-external-sys/"},"headline":"React 使用 Effect 同外部系统协作","image":["https://jblogs.tech/images/covers/react/react-logo.jpg"],"datePublished":"2024-03-24T06:13:34.000Z","dateModified":"2024-03-24T10:16:02.888Z","author":{"@type":"Person","name":"Jeill"},"publisher":{"@type":"Organization","name":"jblogs","logo":{"@type":"ImageObject","url":"https://jblogs.tech/img/header.jpg"}},"description":"有些组件需要与外部系统同步。例如，可能希望根据 React state 控制非 React 组件、设置服务器连接或在组件出现在屏幕上时发送分析日志。使用 Effects 会在组件渲染后运行一些代码，以便可以将组件与 React 之外的某些系统同步。"}</script><link rel="canonical" href="https://jblogs.tech/2024/03/framworks/front_framworks/react/effect-sync-with-external-sys/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main is-sticky"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/header.jpg" alt="jblogs" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/covers/react/react-logo.jpg" alt="React 使用 Effect 同外部系统协作"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-24T06:13:34.000Z" title="2024/3/24 14:13:34">2024-03-24</time>发表</span><span class="level-item"><time dateTime="2024-03-24T10:16:02.888Z" title="2024/3/24 18:16:02">2024-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><span> / </span><a class="link-muted" href="/categories/%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/">前端框架</a><span> / </span><a class="link-muted" href="/categories/%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/">React</a></span><span class="level-item">17 分钟读完 (大约2503个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">React 使用 Effect 同外部系统协作</h1><div class="content"><h2 id="使用-Effect-同步"><a href="#使用-Effect-同步" class="headerlink" title="使用 Effect 同步"></a>使用 Effect 同步</h2><h3 id="什么是-Effect"><a href="#什么是-Effect" class="headerlink" title="什么是 Effect"></a>什么是 Effect</h3><p>React 组件中常见的两种逻辑类型：</p>
<ul>
<li><strong>渲染逻辑代码</strong>。 位于组件的顶层，在这里接收 props 和 state，并对它们进行转换，最终返回你想在屏幕上看到的 JSX。渲染的代码必须是纯粹的——就像数学公式一样，它只应该“计算”结果，而不做其他任何事情。</li>
<li><strong>事件处理程序</strong>。 是嵌套在组件内部的函数，而不仅仅是计算函数。事件处理程序可能会更新输入字段、提交 HTTP POST 请求以购买产品，或者将用户导航到另一个屏幕。事件处理程序包含由特定用户操作（例如按钮点击或键入）引起的“副作用”（它们改变了程序的状态）。</li>
</ul>
<p>另外一种就是Effect，与前述类型不一样的是，<strong>Effect 允许指定由渲染本身，而不是特定事件引起的副作用</strong>。在聊天中发送消息是一个“事件”，因为它直接由用户点击特定按钮引起。然而，建立服务器连接是 Effect，因为它应该发生无论哪种交互导致组件出现。Effect 在屏幕更新后的 <a target="_blank" rel="noopener" href="https://react.docschina.org/learn/render-and-commit">提交阶段</a> 运行。这是一个很好的时机，可以将 React 组件与某个外部系统（如网络或第三方库）同步。</p>
<h3 id="如何编写-Effect"><a href="#如何编写-Effect" class="headerlink" title="如何编写 Effect"></a>如何编写 Effect</h3><p>编写 Effect 需要遵循以下三个规则：</p>
<ol>
<li><strong>声明 Effect</strong>。默认情况下，Effect 会在每次渲染后都会执行。</li>
<li><strong>指定 Effect 依赖</strong>。大多数 Effect 应该按需执行，而不是在每次渲染后都执行。例如，淡入动画应该只在组件出现时触发。连接和断开服务器的操作只应在组件出现和消失时，或者切换聊天室时执行。</li>
<li><strong>必要时添加清理（cleanup）函数</strong>。有时 Effect 需要指定如何停止、撤销，或者清除它的效果。例如，“连接”操作需要“断连”，“订阅”需要“退订”，“获取”既需要“取消”也需要“忽略”。</li>
</ol>
<h4 id="声明-Effect"><a href="#声明-Effect" class="headerlink" title="声明 Effect"></a>声明 Effect</h4><p>在 React 中引入 <code>useEffect</code> Hook，并在组件顶部调用它，传入在每次渲染时都需要执行的代码：</p>
<figure class="highlight javascript"><figcaption><span>声明 effect</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="comment">// 每次渲染后都会执行此处的代码  </span></span><br><span class="line">  &#125;);  </span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，**<code>useEffect</code> 会把相应的代码放到每次屏幕更新渲染之后执行<strong>。以官方例子为例，考虑一个 <code>&lt;VideoPlayer&gt;</code> React 组件。通过传递布尔类型的 <code>isPlaying</code> prop 以控制是播放还是暂停，<code>VideoPlayer</code> 组件渲染了内置的 <code>&lt;video&gt;</code> 标签，由于浏览器的 <code>&lt;video&gt;</code> 标签没有 <code>isPlaying</code> 属性，而控制它的唯一方式是在 DOM 元素上调用 <code>play()</code> 和 <code>pause()</code> 方法。因此，</strong>需要将 <code>isPlaying</code> prop 的值与 <code>play()</code> 和 <code>pause()</code> 等函数的调用进行同步，该属性用于告知当前视频是否应该播放**，在这过程中就需要获取 <code>&lt;video&gt;</code> DOM 节点的引用。<br>如果不使用 Effect，试图在渲染期间通过 ref 调用 <code>play()</code> 或 <code>pause()</code> 是达不到目的的：</p>
<figure class="highlight javascript"><figcaption><span>直接通过 ref 调用 API进行同步</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">VideoPlayer</span>(<span class="params">&#123; src, isPlaying &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isPlaying) &#123;</span><br><span class="line">    ref.<span class="property">current</span>.<span class="title function_">play</span>();  <span class="comment">// 渲染期间不能调用 `play()`。 </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ref.<span class="property">current</span>.<span class="title function_">pause</span>(); <span class="comment">// 同样，调用 `pause()` 也不行。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">video</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">src</span>=<span class="string">&#123;src&#125;</span> <span class="attr">loop</span> <span class="attr">playsInline</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [isPlaying, setIsPlaying] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setIsPlaying(!isPlaying)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        &#123;isPlaying ? &#x27;暂停&#x27; : &#x27;播放&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">VideoPlayer</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">isPlaying</span>=<span class="string">&#123;isPlaying&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">src</span>=<span class="string">&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法是 <strong>使用 <code>useEffect</code> 包裹副作用，把相应逻辑分离到渲染逻辑的计算过程之外</strong>：</p>
<figure class="highlight javascript"><figcaption><span>通过 Effect 分离同步逻辑</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">VideoPlayer</span>(<span class="params">&#123; src, isPlaying &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPlaying) &#123;</span><br><span class="line">      ref.<span class="property">current</span>.<span class="title function_">play</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.<span class="property">current</span>.<span class="title function_">pause</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">video</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">src</span>=<span class="string">&#123;src&#125;</span> <span class="attr">loop</span> <span class="attr">playsInline</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将调用 DOM 方法的操作封装在 Effect 中之后，就可以让 React 先更新屏幕，确定相关 DOM 创建好了以后然后再运行 Effect。这样一来，当 <code>VideoPlayer</code> 组件渲染时（无论是否为首次渲染），React 都会刷新屏幕，确保 <code>&lt;video&gt;</code> 元素已经正确地出现在 DOM 中，然后，运行 Effect，最后，Effect 将根据 <code>isPlaying</code> 的值调用 <code>play()</code> 或 <code>pause()</code>。</p>
<h4 id="指定-Effect-依赖"><a href="#指定-Effect-依赖" class="headerlink" title="指定 Effect 依赖"></a>指定 Effect 依赖</h4><p>一般来说，Effect 会在 <strong>每次</strong> 渲染时执行。<strong>但更多时候，并不需要每次渲染的时候都执行 Effect</strong>。</p>
<ul>
<li>有时这会拖慢运行速度。因为与外部系统的同步操作总是有一定时耗，在非必要时可能希望跳过它。</li>
<li>有时这会导致程序逻辑错误。例如，组件的淡入动画只需要在第一轮渲染出现时播放一次，而不是每次触发新一轮渲染后都播放。</li>
</ul>
<p>为了达到这个目的，可以将 <strong>依赖数组</strong> 传入 <code>useEffect</code> 的第二个参数，以告诉 React <strong>跳过不必要地重新运行 Effect</strong>。比如：</p>
<figure class="highlight javascript"><figcaption><span>传入依赖数组，包含 isPlaying</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, [isPlaying]);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，指定 <code>[isPlaying]</code> 会告诉 React，如果 <code>isPlaying</code> 在上一次渲染时与当前相同，它应该跳过重新运行 Effect。通过这个改变，输入框的输入不会导致 Effect 重新运行，但是按下播放&#x2F;暂停按钮会重新运行 Effect。<br>依赖数组可以包含多个依赖项。当指定的所有依赖项在上一次渲染期间的值与当前值完全相同时，React 会跳过重新运行该 Effect。React 使用 <code>Object.is</code> 比较依赖项的值。但也 <strong>不能随意选择依赖项</strong> 。</p>
<p>值得注意的是，没有依赖数组作为第二个参数，与依赖数组位空数组 <code>[]</code> 的行为是不一致的：</p>
<figure class="highlight javascript"><figcaption><span>useEffect 不同依赖数组的差异</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的代码会在每次渲染后执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的代码只会在组件挂载后执行</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//这里的代码只会在每次渲染后，并且 a 或 b 的值与上次渲染不一致时执行</span></span><br><span class="line">&#125;, [a, b]);</span><br></pre></td></tr></table></figure>

<h4 id="按需添加清理（cleanup）函数"><a href="#按需添加清理（cleanup）函数" class="headerlink" title="按需添加清理（cleanup）函数"></a>按需添加清理（cleanup）函数</h4><p>假设想编写一个 <code>ChatRoom</code> 组件，该组件出现时需要连接到聊天服务器。现在已经提供了 <code>createConnection()</code> API，该 API 返回一个包含 <code>connect()</code> 与 <code>disconnection()</code> 方法的对象。这时可以通过如下方式建立链接：</p>
<figure class="highlight javascript"><figcaption><span>链接聊天室</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">const</span> connection = <span class="title function_">createConnection</span>();  </span><br><span class="line">  connection.<span class="title function_">connect</span>();  </span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<p><strong>Effect 中的代码没有使用任何 props 或 state，此时指定依赖数组为空数组 <code>[]</code>。这告诉 React 仅在组件“挂载”时运行此代码，即首次出现在屏幕上这一阶段</strong>。<br>但是这样会有个问题：在页面切换后，每次返回聊天室页面，聊天组件都会重新挂载，因此，同一个聊天室将会被重复挂载，中间却从未卸载。为了解决这个问题，可以在 Effect 中返回一个 <strong>清理（cleanup）</strong> 函数：</p>
<figure class="highlight javascript"><figcaption><span>从 useEffect 返回清理函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> connection = <span class="title function_">createConnection</span>();</span><br><span class="line">  connection.<span class="title function_">connect</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    connection.<span class="title function_">disconnect</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<p>这样，每次重新执行 Effect 之前，React 都会调用清理函数；组件被卸载时，也会调用清理函数。具体例子如下：</p>
<figure class="highlight javascript"><figcaption><span>聊天室例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createConnection</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 真实的实现会将其连接到服务器，此处代码只是示例</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;✅ 连接中……&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">disconnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;❌ 连接断开。&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ChatRoom</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="title function_">createConnection</span>();</span><br><span class="line">    connection.<span class="title function_">connect</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> connection.<span class="title function_">disconnect</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎来到聊天室！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免一些不必要的Bug，需要注意使用清理函数机制，使得操作成对出现，例如：</p>
<ol>
<li>如果 Effect 订阅了某些事件，清理函数应该退订这些事件;</li>
<li>如果 Effect 对某些内容加入了动画，清理函数应将动画重置；</li>
<li>如果 Effect 将会获取数据，清理函数应该要么中止该数据获取操作，要么忽略其结果；</li>
</ol>
<h3 id="初始化应用时不需要使用-Effect-的情形"><a href="#初始化应用时不需要使用-Effect-的情形" class="headerlink" title="初始化应用时不需要使用 Effect 的情形"></a>初始化应用时不需要使用 Effect 的情形</h3><p>某些逻辑应该只在应用程序启动时运行一次。比如，验证登陆状态和加载本地程序数据。可以将其放在组件之外：</p>
<figure class="highlight javascript"><figcaption><span>组件外检查运行一次的状态</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="comment">// 检查是否在浏览器中运行</span></span><br><span class="line">  <span class="title function_">checkAuthToken</span>();</span><br><span class="line">  <span class="title function_">loadDataFromLocalStorage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，不要在 Effect 中执行购买商品一类的操作，因为，有时即使编写了一个清理函数，也不能避免执行两次 Effect。一方面，开发环境下，Effect 会执行两次，这意味着购买操作执行了两次，但是这并非是预期的结果，所以不应该把这个业务逻辑放在 Effect 中。另一方面，如果用户转到另一个页面，然后按“后退”按钮回到了这个界面，Effect 会随着组件再次挂载而再次执行。故 <strong>它不应该写在 Effect 中，应当把 <code>/api/buy</code> 请求操作移动到购买按钮事件处理程序中</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Effect 构建了与外部系统交互的桥梁，可以实现渲染后，Dom 节点同系统状态同步的目的，但不能滥用 Effect，并且在处理 Effect 时，应当考虑是否需要借助 <code>useEffect</code> 的清理机制，以在页面刷新获组件卸载时清理相应的资源。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>React 使用 Effect 同外部系统协作</p><p><a href="https://jblogs.tech/2024/03/framworks/front_framworks/react/effect-sync-with-external-sys/">https://jblogs.tech/2024/03/framworks/front_framworks/react/effect-sync-with-external-sys/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jeill</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-03-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-03-24</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="link-muted mr-2" rel="tag" href="/tags/React/">React</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/">前端框架</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/03/framworks/front_framworks/react/ref-bridge-between-virtual-real-dom/"><span class="level-item">React Ref 建立虚拟与真实Dom的链接</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "161b88d952490237a17f9d174046257f",
            repo: "JeillZhang.github.io",
            owner: "JeillZhang",
            clientID: "eb53201d155142dc8f9a",
            clientSecret: "d945224d97b8236e825c4ba4294d6029d6b9c122",
            admin: ["JeillZhang"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/header.jpg" alt="Jeill"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jeill</p><p class="is-size-6 is-block">Love today...</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/JeillZhang" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#使用-Effect-同步"><span class="level-left"><span class="level-item">1</span><span class="level-item">使用 Effect 同步</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是-Effect"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">什么是 Effect</span></span></a></li><li><a class="level is-mobile" href="#如何编写-Effect"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">如何编写 Effect</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#声明-Effect"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">声明 Effect</span></span></a></li><li><a class="level is-mobile" href="#指定-Effect-依赖"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">指定 Effect 依赖</span></span></a></li><li><a class="level is-mobile" href="#按需添加清理（cleanup）函数"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">按需添加清理（cleanup）函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#初始化应用时不需要使用-Effect-的情形"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">初始化应用时不需要使用 Effect 的情形</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">2</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/header.jpg" alt="jblogs" height="28"></a><p class="is-size-7"><span>&copy; 2024 Jeill</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> &amp; <a href="https://gitee.com/JeillZhang" target="_blank" rel="noopener">Jeill(Personalized)</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>