{"posts":[{"title":"Docker 容器操作","text":"","link":"/2024/03/container/docker-container-oprator/"},{"title":"Docker 镜像操作","text":"什么是镜像镜像操作命令docker image search","link":"/2024/03/container/docker-images-oprator/"},{"title":"React 事件响应及单组件状态处理","text":"事件响应事件处理函数 使用 React 可以在 JSX 中添加 事件处理函数。其中事件处理函数为自定义函数，它将在响应交互（如点击、悬停、表单输入框获得焦点等）时触发。 React 官方文档 – 响应事件 大多元素均可绑定响应的事件，以按钮为例，最常使用的事件为点击事件。在 Ract 中为一个按钮添加点击事件非常简单，只需要在组件内创建一个事件处理函数，并在标签返回时，将其绑定到 onClick 属性上即可： 为按钮绑定点击事件12345678910111213function App() { function handleButtonClick() { alert(&quot;Button clicked.&quot;); } return ( &lt;button onClick={handleButtonClick}&gt; Click me &lt;/button&gt; );}export default App; 事件处理函数通常有如下特点： 通常在 组件内部 定义。（这样做的好处是可以直接访问组件内部的 props 。） 名称以 handle 开头，后跟事件名称。（这只是一种惯例，并非强制。） 一种更为简洁的方式为使用 Javascript 的箭头函数，为一个元素内联绑定事件处理函数，这种方式当处理函数比较小的情况下是非常方便的： 内联函数绑定事件处理1234567891011function App() { return ( &lt;button onClick={()=&gt;{ alert(&quot;Button clicked.&quot;); }}&gt; Click me &lt;/button&gt; );}export default App; 通过 props 传递事件处理函数通常，会在父组件中定义子组件的事件处理函数，这样做提高了子组件的可重用性。例如官网如下示例，根据需要，将不通的事件处理函数传递给按钮组件后，可以实现文件上传、电影点播等不同功能，但是子组件 Button 内部编码却不需要做任何改变。 传递事件处理函数给子组件12345678910111213141516171819202122232425262728293031323334353637 // 定义公共组件，其点击事件在使用时传入function Button({ onClick, children }) { return ( &lt;button onClick={onClick}&gt; {children} // 子组件接收标签内容 &lt;/button&gt; );}function PlayButton({ movieName }) { function handlePlayClick() { alert(`正在播放 ${movieName}！`); } return ( &lt;Button onClick={handlePlayClick}&gt; 播放 &quot;{movieName}&quot; &lt;/Button&gt; );}function UploadButton() { return ( &lt;Button onClick={() =&gt; alert('正在上传！')}&gt; 上传图片 &lt;/Button&gt; );}export default function Toolbar() { return ( &lt;div&gt; &lt;PlayButton movieName=&quot;迪迦奥特曼&quot; /&gt; &lt;UploadButton /&gt; &lt;/div&gt; );} 事件传播行为事件处理函数还会捕获任何来自子组件的事件，即事件从发生的地方开始，沿着 UI 树向上传播。例如： 子组件事件传播行为1234567891011export default function Toolbar() { return ( &lt;div className=&quot;Toolbar&quot; onClick={() =&gt; { alert('你点击了 toolbar ！'); }}&gt; &lt;button onClick={() =&gt; alert('正在播放！')}&gt; 播放电影 &lt;/button&gt; &lt;/div&gt; );} 上述实例中，div 及其子组件 button 均添加了点击事件，虽然行为不同，但是当点击按钮出发其事件处理后，对应的点击事件会沿着UI树向上传播至 div 中，进而触发 div 的点击事件回调其处理函数。所以会看到两次弹窗。但是，这种传播是可以被中断的。每个事件处理函数接收一个 事件对象 作为唯一的参数，可以使用此对象来读取有关事件的信息。同样的，若想阻止事件向上传播，可以在子组件事件处理函数的开始处，借助事件的 e.stopPropagation() 方法实现。（浏览器内置组件可以通过自定义组件来包装一下。） 阻止子组件事件传播行为12345678910function Button({ onClick, children }) { return ( &lt;button onClick={e =&gt; { e.stopPropagation(); // 阻止事件传播至父组件 onClick(); }}&gt; {children} &lt;/button&gt; );} 阻止组件默认行为某些浏览器事件具有与事件相关联的默认行为。例如，点击 &lt;form&gt; 表单内部的按钮会触发表单提交事件，默认情况下将重新加载整个页面，但是这种行为也是可以事件对象的 e.preventDefault() 方法来阻止的： 阻止组件的默认行为1234567891011export default function Signup() { return ( &lt;form onSubmit={e =&gt; { e.preventDefault(); // 阻止组件的默认行为 alert('提交表单！'); }}&gt; &lt;input /&gt; &lt;button&gt;发送&lt;/button&gt; &lt;/form&gt; );} State事件处理函数是执行副作用的最佳位置。同渲染函数不同，事件处理函数不需要是 纯函数，因此它是用来更改某些值的绝佳位置。例如，更改输入框的值以响应键入，或者更改列表以响应按钮的触发。但是，在修改数据前，通常需要记住修改的值，这在 React 中便是通过 State （状态）来实现的。通常情况下，在组件内部使用普通变量保存状态数据后，在事件（例如按钮的点击事件）处理过程中改变其数据后，无法实现新内容的渲染，这是因为： 局部变量无法在多次渲染中持久保存。 当 React 再次渲染组件时，会从头开始渲染，不会考虑之前对局部变量的任何更改。 更改局部变量不会触发渲染。 React 没有意识到它需要使用新数据再次渲染组件。 在 React 中，以上功能可以通过 Hook 函数 useState 实现，该函数接收1个参数，为状态的初始值；返回值可以解构为两个值：其中第一个取值为 状态 ，第二个值为 setter 函数，用于改变状态的取值，进而触发 React 重新渲染组件。 添加一个 state 变量要添加 state 变量，先从文件顶部的 React 中导入 useState： 导入 useState Hook1import { useState } from 'react'; 然后接收 Hook 返回的两个值，这两个取值是相互对应的： 解构 useState 的返回值1const [state, setXxx] = useState(inieState); 官网提供的完整实例如下： 官方示例1234567891011121314151617181920212223242526272829303132333435import { useState } from 'react';import { sculptureList } from './data.js';export default function Gallery() { const [index, setIndex] = useState(0); function handleClick() { // React 会记住中间值 // 即使再次渲染时看到的仍是初始值，但是会使用中间值进行相应的渲染 setIndex(index + 1); } let sculpture = sculptureList[index]; return ( &lt;&gt; &lt;button onClick={handleClick}&gt; Next &lt;/button&gt; &lt;h2&gt; &lt;i&gt;{sculpture.name} &lt;/i&gt; by {sculpture.artist} &lt;/h2&gt; &lt;h3&gt; ({index + 1} of {sculptureList.length}) &lt;/h3&gt; &lt;img src={sculpture.url} alt={sculpture.alt} /&gt; &lt;p&gt; {sculpture.description} &lt;/p&gt; &lt;/&gt; );} Hooks ——以 use 开头的函数——只能在组件或自定义 Hook 的最顶层调用。 你不能在条件语句、循环语句或其他嵌套函数内调用 Hook。Hook 是函数，但将它们视为关于组件需求的无条件声明会很有帮助。在组件顶部 “use” React 特性，类似于在文件顶部“导入”模块。 React 文档 – state 组件的记忆 每个组件可以同时定义多个不同的 state ，不会相互影响。但如果发现经常同时更改多个 state 变量，那么可以由一个值为对象的 state 变量的多个字段对应一个 state 变量，在事件处理过程中，通过更改对象的相应字段即可。 State 是隔离且私有的 State 是屏幕上组件实例内部的状态。换句话说，如果你渲染同一个组件两次，每个副本都会有完全隔离的 state！改变其中一个不会影响另一个。 React 文档 – state 组件的记忆 渲染和提交在 React 中，UI 的更新通常有三个步骤： 触发一次渲染 初次渲染。应用启动时，会触发初次渲染。这个过程通过调用目标 DOM 节点的 createRoot，然后再调用组件调用 render 函数完成。 状态更新时重新渲染。一旦组件被初次渲染，就可以通过使用 setter 函数更新其状态来触发之后的渲染。更新组件的状态会自动将一次渲染送入队列。 set 函数 仅更新 下一次 要渲染的状态变量。如果在调用 setter 函数后读取状态变量，则还是会看到之前的旧值；如果提供的新值与当前 state 相同，则不会触发对应组件及子组件的渲染。 React 渲染组件 在进行初次渲染时, React 会调用根组件。 对于后续的渲染, React 会调用内部状态更新触发了渲染的函数组件。 这个过程是递归的：如果更新后的组件会返回某个另外的组件，那么 React 接下来就会渲染返回的组件，而如果返回的组件又返回了某个组件，那么 React 接下来就会渲染继续渲染后续返回的组件，以此类推。这个过程会持续下去，直到没有更多的嵌套组件并且 React 确切知道哪些东西应该显示到屏幕上为止。 React 把更改提交到 DOM 上 对于初次渲染， React 会使用 appendChild() DOM API 将其创建的所有 DOM 节点放在屏幕上。 对于重渲染， React 将应用最少的必要操作（在渲染时计算。），以使得 DOM 与最新的渲染输出相互匹配。 state 的进一步理解state 如同一张快照 是官方对 state 的一个描述。据此，每次状态变化触发渲染时，渲染的结果都是根据上一次渲染后的结果计算得到。因此，即使在事件处理时多次根据状态的值计算的下一次渲染状态，得到的结果都是相同的。例如： 根据快照 number 计算下一次渲染的结果1234567891011121314151617import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 1); setNumber(number + 1); setNumber(number + 1); }}&gt;+3&lt;/button&gt; &lt;/&gt; )} 上述官方示例中，虽然在按钮的事件处理函数中对 number 状态连续做了三次加一，但是因为都是基于上一次渲染结果的快照（即组件加载时的 0）计算更新，所以最终在下一次渲染时，number 的值为 1，而非 3。另一方面，根据官方文档： 一个 state 变量的值永远不会在一次渲染的内部发生变化， 即使其事件处理函数的代码是异步的。 React 文档 – state 如同一张快照 在一个新的场景下，如果先对状态进行更新，触发组件重新渲染以后，在直接使用对应的状态（例如弹窗显示等），实际上使用的值是上一次渲染的快照值。 渲染组建后随机使用状态做弹窗123456789101112131415import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 5); alert(number); }}&gt;+5&lt;/button&gt; &lt;/&gt; )} 多次更新状态值 React 会等到事件处理函数中的 所有 代码都运行完毕再处理你的 state 更新。 React 文档 – 把一系列 state 更新加入队列 实际上，事件处理函数及其中任何代码执行完成 之后，UI 才会更新，也就是所谓的批处理，这可以保证渲染结果的正确性。在上一节中的示例中，更新状态值都是基于快照的值进行的，而传递给更新函数的都是计算后的值。有时候需要连续多次的对状态的值进行更新，例如，这种场景下，可以传入一个函数给到设值函数，这样一个更新函数接收相应的参数，用于累积结果： 根据更新队列中的值 n，计算后续更新的值12345678910111213141516import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 5); setNumber(n =&gt; n + 1); }}&gt;增加数字&lt;/button&gt; &lt;/&gt; )} 更新 state 中的对象及数组在 React 中，如果状态对应的是一个对象或者数组，如果单纯相应对象的某个属性发生变化，是不会通知到 React 进行重新渲染的。只有通过设值函数利用修改后的 新对象 或者 新数组 更新状态，让 React 感知到相应变化，才能触发组件的重新渲染。总体上，把握一个原则， 不要妄想直接改变原有对象触发渲染，不管什么时候，要想React重新渲染组件，就通过复制或者能够返回一个新对象/数组的函数，传递一个全新的状态至对应状态的设置函数 。例如： 传递一个新的对象，触发渲染并更新红点位置1234567891011121314151617181920212223242526272829303132import { useState } from 'react';export default function MovingDot() { const [position, setPosition] = useState({ x: 0, y: 0 }); return ( &lt;div onPointerMove={e =&gt; { setPosition({ // 传入一个新的对象 x: e.clientX, y: e.clientY }); }} style={{ position: 'relative', width: '100vw', height: '100vh', }}&gt; &lt;div style={{ position: 'absolute', backgroundColor: 'red', borderRadius: '50%', transform: `translate(${position.x}px, ${position.y}px)`, left: -10, top: -10, width: 20, height: 20, }} /&gt; &lt;/div&gt; );} 如果对象比较复杂，可以使用 展开语法 进行对象复制： 展开语法复制对象/数组1234567891011// 复制对象setPerson({ ...person, // 复制上一个 person 中的所有字段 firstName: e.target.value // 但是覆盖 firstName 字段 });// 复制数组setArtists([{ id: nextId++, name: name }, ...artists // 将原数组中的元素放在末尾 ]); 如果对象比较复杂，数据一些逻辑较为啰嗦，可以利用 Immer 库简化相应的更新操作。添加相应的依赖： immer 依赖12345678910111213141516{ &quot;dependencies&quot;: { &quot;immer&quot;: &quot;1.7.3&quot;, &quot;react&quot;: &quot;latest&quot;, &quot;react-dom&quot;: &quot;latest&quot;, &quot;react-scripts&quot;: &quot;latest&quot;, &quot;use-immer&quot;: &quot;0.5.1&quot; }, &quot;scripts&quot;: { &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; }, &quot;devDependencies&quot;: {}} Immer 使用举例： Immer 用法123456789101112131415161718192021222324252627282930313233343536373839import { useState } from 'react';import { useImmer } from 'use-immer';const initialList = [ { id: 0, title: 'Big Bellies', seen: false }, { id: 1, title: 'Lunar Landscape', seen: false }, { id: 2, title: 'Terracotta Army', seen: true },];...export default function BucketList() { const [myList, updateMyList] = useImmer( initialList ); function handleToggleMyList(id, nextSeen) { updateMyList(draft =&gt; { const artwork = draft.find(a =&gt; a.id === id ); artwork.seen = nextSeen; }); } return ( &lt;&gt; &lt;h1&gt;艺术愿望清单&lt;/h1&gt; &lt;h2&gt;我想看的艺术清单：&lt;/h2&gt; &lt;ItemList artworks={myList} onToggle={handleToggleMyList} /&gt; &lt;h2&gt;你想看的艺术清单：&lt;/h2&gt; &lt;ItemList artworks={yourList} onToggle={handleToggleYourList} /&gt; &lt;/&gt; );}...","link":"/2024/03/framworks/front_framworks/react/event-response-and-single-comp-state/"},{"title":"Docker 安装及配置","text":"1 安装1.1 debain 使用脚本自动安装 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 手动安装 更新软件包索引，并且安装必要的依赖软件，来添加一个新的 HTTPS 软件源 12sudo apt updatesudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common 使用下面的 curl 导入源仓库的 GPG key： 12345# 官方：curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# Aliyuncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 安装 Docker 最新版本 12sudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 启动Docker 12sudo systemctl enable dockersudo systemctl start docker 建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 123456# 建立 docker 组：sudo groupadd docker# 将当前用户加入 docker 组：sudo usermod -aG docker $USER# 退出当前终端并重新登录 docker 镜像 1234567891011121314151617181920网易：http://hub-mirror.c.163.com中科大镜像地址：http://mirrors.ustc.edu.cn/中科大github地址：https://github.com/ustclug/mirrorrequestAzure中国镜像地址：http://mirror.azure.cn/Azure中国github地址：https://github.com/Azure/container-service-for-azure-chinaDockerHub镜像仓库: https://hub.docker.com/ 阿里云镜像仓库： https://cr.console.aliyun.com google镜像仓库： https://console.cloud.google.com/gcr/images/google-containers/GLOBAL （如果你本地可以翻墙的话是可以连上去的 ）coreos镜像仓库： https://quay.io/repository/ RedHat镜像仓库： https://access.redhat.com/containers配置：sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot;: [&quot;https://cr.console.aliyun.com&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker 1.2 Centos 使用脚本自动安装 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 手动安装 安装依赖 1sudo yum install -y yum-utils # openEuler 自带 dnf 管理器，可直接管理 yum 源 配置docker仓库 12345官方：sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoAliyun:sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 下载安装 12sudo yum makecache fast # 更新索引sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin （openEuler）更新索引时，可能会报错404，可按如下方法解决 1234567cd /etc/yum.repos.d/# ls -lhrt # -rw-r--r--. 1 root root 2.7K Dec 9 20:33 openEuler.repo.bak# -rw-r--r--. 1 root root 3.0K Dec 9 20:37 openEuler.repo# -rw-r--r--. 1 root root 2.0K Feb 3 16:45 docker-ce.repo编辑 docker-ce.repo，将 $releasever 替换为 8，即CentOS8，使得能够在阿里云的centos仓库中找到对应的工具","link":"/2024/02/container/docker-install/"},{"title":"React UI 中的声明式思维","text":"声明式的考虑UI声明式UI意味着不必直接启用、关闭、显示或隐藏组件，而是只需要 声明你想要显示的内容， React 就会通过计算得出该如何去更新 UI。在 React 中，可以通过如下步骤思考如何实现UI效果： 定位组件中不同的视图状态 确定是什么触发了这些 state 的改变 表示内存中的 state（需要使用 useState） 删除任何不必要的 state 变量 连接事件处理函数去设置 state 定位组件中不同的视图状态可视化 UI 界面中用户可能看到的所有不同的“状态”，例如： 无数据：表单有一个不可用状态的“提交”按钮。 输入中：表单有一个可用状态的“提交”按钮。 提交中：表单完全处于不可用状态，加载动画出现。 成功时：显示“成功”的消息而非表单。 错误时：与输入状态类似，但会多错误的消息。 在添加逻辑之前去“模拟”不同的状态或创建“模拟状态”，这个过程可在书写逻辑前快速迭代 UI。官网示例代码如下： 表单布局12345678910111213141516171819202122export default function Form({ status = 'empty'}) { if (status === 'success') { return &lt;h1&gt;That's right!&lt;/h1&gt; } return ( &lt;&gt; &lt;h2&gt;City quiz&lt;/h2&gt; &lt;p&gt; In which city is there a billboard that turns air into drinkable water? &lt;/p&gt; &lt;form&gt; &lt;textarea /&gt; &lt;br /&gt; &lt;button&gt; Submit &lt;/button&gt; &lt;/form&gt; &lt;/&gt; )} 确定是什么触发了这些状态的改变触发 state 的更新来响应两种输入： 人为输入。比如点击按钮、在表单中输入内容，或导航到链接。 计算机输入。比如网络请求得到反馈、定时器被触发，或加载一张图片。 以上两种情况中，必须设置 state 变量 去更新 UI。对于正在开发中的表单来说，需要改变 state 以响应几个不同的输入： 改变输入框中的文本时（人为）应该根据输入框的内容是否是空值，从而决定将表单的状态从空值状态切换到输入中或切换回原状态。 点击提交按钮时（人为）应该将表单的状态切换到提交中的状态。 网络请求成功后（计算机）应该将表单的状态切换到成功的状态。 网络请求失败后（计算机）应该将表单的状态切换到失败的状态，与此同时，显示错误信息。 可通过如下表示方法，对状态变化进行可视化： 通过 useState 表示内存中的 state接下来需要在内存中通过 useState表示组件中的视图状态。诀窍很简单：state 的每个部分都是“处于变化中的”，并且让“变化的部分”尽可能的少。根据上一部分的状态图，需要存储输入的 answer 以及用于存储最后一个错误的 error，这是必须的两个状态。除此之外，一开始可以添加足够多的 state 开始，确保所有可能的视图状态都囊括其中： 表单状态12345678910// 必须状态const [answer, setAnswer] = useState(''); const [error, setError] = useState(null);// 其余状态const [isEmpty, setIsEmpty] = useState(true); const [isTyping, setIsTyping] = useState(false); const [isSubmitting, setIsSubmitting] = useState(false); const [isSuccess, setIsSuccess] = useState(false); const [isError, setIsError] = useState(false); 删除任何不必要的 state 变量为避免 state 内容中的重复，从而只需要关注那些必要的部分，可以对前一步中的状态进行重构。这可以让组件更容易被理解，减少重复并且避免歧义，同时防止出现在内存中的 state 不代表任何你希望用户看到的有效 UI 的情况。可以通过如下一些问题促进对状态的思考： 这个 state 是否会导致矛盾？例如，isTyping 与 isSubmitting 的状态不能同时为 true。矛盾的产生通常说明了这个 state 没有足够的约束条件。两个布尔值有四种可能的组合，但是只有三种对应有效的状态。为了将“不可能”的状态移除，可以将 'typing'、'submitting' 以及 'success' 这三个中的其中一个与 status 结合。 相同的信息是否已经在另一个 state 变量中存在？另一个矛盾：isEmpty 和 isTyping 不能同时为 true。通过使它们成为独立的 state 变量，可能会导致它们不同步并导致 bug。幸运的是，可以移除 isEmpty 转而用 message.length === 0。 是否可以通过另一个 state 变量的相反值得到相同的信息？isError 是多余的，因为可以检查 error !== null。 重构完成以后，剩下三个必要的状态： 精简后的表单状态123const [answer, setAnswer] = useState(''); const [error, setError] = useState(null); const [status, setStatus] = useState('typing'); // 'typing', 'submitting', or 'success' 连接事件处理函数以设置 state最后，创建事件处理函数以设置 state 变量。下面是绑定好事件的最终表单： 绑定事件处理函数后的表单示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import { useState } from 'react';export default function Form() { const [answer, setAnswer] = useState(''); const [error, setError] = useState(null); const [status, setStatus] = useState('typing'); if (status === 'success') { return &lt;h1&gt;That's right!&lt;/h1&gt; } async function handleSubmit(e) { e.preventDefault(); setStatus('submitting'); try { await submitForm(answer); setStatus('success'); } catch (err) { setStatus('typing'); setError(err); } } function handleTextareaChange(e) { setAnswer(e.target.value); } return ( &lt;&gt; &lt;h2&gt;City quiz&lt;/h2&gt; &lt;p&gt; In which city is there a billboard that turns air into drinkable water? &lt;/p&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;textarea value={answer} onChange={handleTextareaChange} disabled={status === 'submitting'} /&gt; &lt;br /&gt; &lt;button disabled={ answer.length === 0 || status === 'submitting' }&gt; Submit &lt;/button&gt; {error !== null &amp;&amp; &lt;p className=&quot;Error&quot;&gt; {error.message} &lt;/p&gt; } &lt;/form&gt; &lt;/&gt; );}function submitForm(answer) { // Pretend it's hitting the network. return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { let shouldError = answer.toLowerCase() !== 'lima' if (shouldError) { reject(new Error('Good guess but a wrong answer. Try again!')); } else { resolve(); } }, 1500); });} 总结总的来说，在 React 中，可从 UI 整体出发，为每个视图状态先声明 UI。在组件开发过程中，列出所有状态及其转换关系，通过 useState 将状态放置于组件内，在移除冗余状态后，利用设值函数及事件处理函数，根据事件结果调整状态变化。","link":"/2024/03/framworks/front_framworks/react/thinking-in-declarative-ui/"},{"title":"Docker 仓库配置及使用","text":"","link":"/2024/03/container/docker-repo-oprator/"}],"tags":[{"name":"容器化","slug":"容器化","link":"/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"前端框架","slug":"前端框架","link":"/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"categories":[{"name":"容器化","slug":"容器化","link":"/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"Docker","slug":"容器化/Docker","link":"/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/Docker/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"前端框架","slug":"框架/前端框架","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"React","slug":"框架/前端框架/React","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/"}],"pages":[]}