{"posts":[{"title":"Docker 安装及配置","text":"1 安装1.1 debain 使用脚本自动安装 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 手动安装 更新软件包索引，并且安装必要的依赖软件，来添加一个新的 HTTPS 软件源 12sudo apt updatesudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common 使用下面的 curl 导入源仓库的 GPG key： 12345# 官方：curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# Aliyuncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 安装 Docker 最新版本 12sudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 启动Docker 12sudo systemctl enable dockersudo systemctl start docker 建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 123456# 建立 docker 组：sudo groupadd docker# 将当前用户加入 docker 组：sudo usermod -aG docker $USER# 退出当前终端并重新登录 docker 镜像 1234567891011121314151617181920网易：http://hub-mirror.c.163.com中科大镜像地址：http://mirrors.ustc.edu.cn/中科大github地址：https://github.com/ustclug/mirrorrequestAzure中国镜像地址：http://mirror.azure.cn/Azure中国github地址：https://github.com/Azure/container-service-for-azure-chinaDockerHub镜像仓库: https://hub.docker.com/ 阿里云镜像仓库： https://cr.console.aliyun.com google镜像仓库： https://console.cloud.google.com/gcr/images/google-containers/GLOBAL （如果你本地可以翻墙的话是可以连上去的 ）coreos镜像仓库： https://quay.io/repository/ RedHat镜像仓库： https://access.redhat.com/containers配置：sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot;: [&quot;https://cr.console.aliyun.com&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker 1.2 Centos 使用脚本自动安装 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 手动安装 安装依赖 1sudo yum install -y yum-utils # openEuler 自带 dnf 管理器，可直接管理 yum 源 配置docker仓库 12345官方：sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoAliyun:sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 下载安装 12sudo yum makecache fast # 更新索引sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin （openEuler）更新索引时，可能会报错404，可按如下方法解决 1234567cd /etc/yum.repos.d/# ls -lhrt # -rw-r--r--. 1 root root 2.7K Dec 9 20:33 openEuler.repo.bak# -rw-r--r--. 1 root root 3.0K Dec 9 20:37 openEuler.repo# -rw-r--r--. 1 root root 2.0K Feb 3 16:45 docker-ce.repo编辑 docker-ce.repo，将 $releasever 替换为 8，即CentOS8，使得能够在阿里云的centos仓库中找到对应的工具","link":"/2024/02/container/docker-install/"},{"title":"Docker 容器操作","text":"","link":"/2024/03/container/docker-container-oprator/"},{"title":"SQL 优化基本概念","text":"1、必知1.1 基数某个列唯一键的数量被称为基数。基数的高低通常影响数据的分布。可以使用如下语句查询列的基数与列上数据分布情况： 查询某一列的基数及数据分布12345-- 查询基数select count(distinct col_name) from table_name;-- 查询某列数据分布情况select col_name, count(*) from table_name group by col_name order by 2 desc; 依据基数，计算某一列数据占总量的百分比，可以通过此值大致判断当前查询应该走索引还是全表扫描：当查询结果返回表中 5% 以内的数据时，应该走索引，否则应该走全表扫描。其原因与后面介绍的回表概念有关。 1.2 选择性基数与总行数的比值乘以100%被称为选择性。若要获取选择性，需要先收集统计信息（后文介绍），可以使用如下代码收集表的统计信息： 收集表的统计信息1234567891011BEGIN DBMS_STATS.GATHER_TABLE_STATS( ownname =&gt; 'username', tabname =&gt; 'table_name', estimate_percent =&gt; '100', method_opt =&gt; 'for all columns size 1', no_invalidate =&gt; FALSE, degree =&gt; 1, cascade =&gt; TRUE); END;/ 收集完统计信息后，可以通过如下语句查看表每个列的基数与选择性： 查询表中各列基数及选择性1234567891011select a.COLUMN_NAME, b.NUM_ROWS, a.NUM_DISTINCT as Cardinality, round(a.NUM_DISTINCT / b.NUM_ROWS * 100, 2) as selectivity, a.HISTOGRAM, a.NUM_BUCKETS from &quot;PUBLIC&quot;.DBA_TAB_COL_STATISTICS a, &quot;PUBLIC&quot;.DBA_TABLES b where a.OWNER = b.OWNER and a.TABLE_NAME = b.TABLE_NAME and a.OWNER = 'user_name' and a.TABLE_NAME = 'table_name'; 通常，当一个列的选择性 &gt; 20% 时，对应列的数据分布就比较均衡。如果一个列出现在 where 条件中，并且数据分布比较均衡，就应该给对应的列创建索引，以便提高大表的查询性能。可以按如下步骤，利用sql脚本自动抓取出需要创建索引的列： 运行一条 SQL 语句； 刷新数据库监控信息： 刷新数据库监控信息123BEGIN DBMS_STATS.flush_database_monitoring_info; end; 运行自动化脚本获取需要创建索引的列 获取需要创建索引的列12345678910111213141516171819202122232425select owner, COLUMN_NAME, NUM_ROWS, Cardinality, selectivity, 'Need index' as notice from (select a.COLUMN_NAME, b.NUM_ROWS, a.NUM_DISTINCT as Cardinality, round(a.NUM_DISTINCT / b.NUM_ROWS * 100, 2) as selectivity, a.HISTOGRAM, a.NUM_BUCKETS from &quot;PUBLIC&quot;.DBA_TAB_COL_STATISTICS a, &quot;PUBLIC&quot;.DBA_TABLES b where a.OWNER = b.OWNER and a.TABLE_NAME = b.TABLE_NAME and a.OWNER = 'user_name' and a.TABLE_NAME = 'table_name') where selectivity &gt;= 20 and COLUMN_NAME not in (select COLUMN_NAME from &quot;PUBLIC&quot;.DBA_IND_COLUMNS where TABLE_OWNER = 'user_name' and TABLE_NAME = 'table_name') and COLUMN_NAME in (select c.name from sys.COL_USAGE$ u, sys.OBJ$ o, sys.COL$ c, sys.USER$ r where o.OBJ# = u.OBJ# and c.OBJ# = u.OBJ# and c.COL# = u.INTCOL# and r.name = 'username' and o.NAME = 'table_name'); 1.3 直方图直方图为一种统计信息，表示某列数据的分布情况。如果没有及时收集直方图统计信息，会导致基于成本的优化器（CBO）认为对应列数据分布是均衡的，从而可能导致因统计信息不准而走错执行计划，出现性能问题。选择性中收集统计信息后，查询的结果中，若 HISTOGRAM 为 None ，则表示没有收集直方图统计信息。这是因为收集统计信息时，method_opt 被配置为 for all columns size 1 。此时如果对基数较低的列进行查询，返回的结果数目可能远小于执行计划估算的结果。如果想要 CBO 估算的行数更加准确，可以在收集统计信息时，将method_opt 被配置为 for columns owner size skewonly 。 具体什么时候应该收集直方图信息，一个指导性原则是：当列出现在 where 条件中，列的选择性小于 1% 并且该列没有收集过直方图信息。下列脚本可以自动化的抓取出需要收集直方图信息的列： 获取需要收集直方图信息的列1234567891011121314151617select a.COLUMN_NAME, b.NUM_ROWS, a.NUM_DISTINCT as Cardinality, round(a.NUM_DISTINCT / b.NUM_ROWS * 100, 2) as selectivity, a.HISTOGRAM, 'Need gather histogram.' as Notice from &quot;PUBLIC&quot;.DBA_TAB_COL_STATISTICS a, &quot;PUBLIC&quot;.DBA_TABLES b where a.OWNER = b.OWNER and a.TABLE_NAME = b.TABLE_NAME and a.OWNER = 'user_name' and a.TABLE_NAME = 'table_name' and NUM_DISTINCT / NUM_ROWS &lt; 0.01 and (a.OWNER, a.TABLE_NAME, a.COLUMN_NAME) in (select r.name as owner, o.NAME as table_name, c.name as column_name from sys.COL_USAGE$ u, sys.OBJ$ o, sys.COL$ c, sys.USER$ r where o.OBJ# = u.OBJ# and c.OBJ# = u.OBJ# and c.COL# = u.INTCOL# and r.name = 'username' and o.NAME = 'table_name') and a.HISTOGRAM = 'NONE'; 1.4 回表通过索引命中记录的 rowid 访问表中的数据被称为回表。回表一般为单块读，回表的次数太多会严重影响 SQL 的性能，如果回表次数过多，就应该走全表扫表了。这也就是为什么返回表中 5% 以内的数据应该走索引，而超过 5% 以后，就应该走全表扫描的原因。一般来说，当要查询的列也包含在索引中时，就不需要回表，因此可以通过建立组合索引的方式开消除回表，提升查询性能；如果一个 SQL 语句有多个过滤条件，但是只有一个列或者部分列创建了索引，会发生回表再过滤，此时也需要创建组合索引以消除回表再过滤。 1.5 集群因子集群因子用于判断索引回表需要消耗的物理IO次数。 如果集群因子与块数接近，说明表的数据基本上是有序的，而却其顺序基本与索引的顺序一致。此时进行索引范围或者索引全扫描时，回表只需要读取少量的数据块就能完成； 如果集群因子与表的记录数接近，说明表的数据和索引的顺序差异很大，在进行索引范围或者索引全扫描时，回表会读取更多的数据块。 集群因子只会影响索引范围扫描以及索引全扫描，因为这两种方式会有大量数据回表，而集群因子主要影响索引回表时的物理IO次数，从而影响 SQL 的查询性能。如果一条SQL查询时不回表，或者返回的数据量较小，此时集群因子的大小对性能几乎没有影响。以下脚本用于计算某一列数据的集群因子： 计算集群因子1234567select sum(case when block#1 = block#2 and file#1 = file#2 then 0 else 1 end) as clustering_factor (select DBMS_ROWID.rowid_relative_fno(ROWID) file#1, load(DBMS_ROWID.rowid_relative_fno(ROWID), 1, null) over(order by OBJECT_ID) file#2, DBMS_ROWID.rowid_block_number(ROWID) block#1, load(DBMS_ROWID.rowid_block_number(ROWID), 1, null) over(order by OBJECT_ID) block#2 from table_name where OBJECT_ID is not null); 1.6 表间关系表间关系有：1:1、1:N、N:N 。如果两表关系为 1:1 ，关联以后数据不会有重复；如果两表关系为 1:N，关联以后的数据为 N 的关系；如果两表关系为 N:N，关联后的数据为笛卡尔积的关系。 2、统计信息2.1 统计信息分类2.2 统计信息参数设置2.3 检查统计信息是否过期2.4 扩展统计信息2.5 动态采样2.6 定制统计信息收集策略","link":"/2024/11/sqlperfopt/sql-perf-opt-chapt1/"},{"title":"Docker 仓库配置及使用","text":"","link":"/2024/03/container/docker-repo-oprator/"},{"title":"Gradle 安装及初始配置","text":"Gradle 安装配置安装从 这里 下载 Gradle 软件包。下载后，解压后的目录放置于想要安装的路径下即可。 配置环境变量配置Mac / Linux 1export PATH=$PATH:[gradle_install_path]/gradle-8.7/bin Windows 123此电脑 &gt; 属性 &gt; 高级系统设置 &gt; 环境变量在系统属性下找到Path，新建，填入安装路径即可。 下载配置 添加环境变量 1GRADLE_USER_HOME=your_custom_repo_dir # 配置下载gradle库下载路径 配置国内镜像源 全局配置，在gradle安装目录下的 init.d 文件夹中新建 init.gradle 文件，并添加入下配置 123456789# 全局配置# 阿里开源镜像allprojects { repositories { maven { url 'https://maven.aliyun.com/repository/public/' } mavenLocal() mavenCentral() }}","link":"/2024/04/devenvcfg/gradle/gradle-install-cfg/"},{"title":"Maven 安装及初始配置","text":"Maven 安装配置安装Maven安装比较简单，从 这里 下载 Maven 软件包，Windows 选择 zip 格式，Mac 或 Linux 选择 tar.gz 格式。下载后，解压后的目录放置于想要安装的路径下即可。 配置环境变量配置Mac / Linux 1export PATH=$PATH:[maven_install_path]/apache-maven-3.9.6/bin Windows 123此电脑 &gt; 属性 &gt; 高级系统设置 &gt; 环境变量在系统属性下找到Path，新建，填入安装路径即可。 下载配置 打开 apache-maven-3.9.6/conf/settings.xml 文件，配置 &lt;localRepository&gt;your_maven_repo_dir&lt;/localRepository&gt; 为 Maven 安装路径即可。 在 mirrors 下配置 mirror 为国内相关镜像，可大幅提高下载速度 1234567891011121314&lt;!-- 华为开源镜像 --&gt;&lt;mirror&gt; &lt;id&gt;huaweicloud&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;https://mirrors.huaweicloud.com/repository/maven/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 阿里开源镜像 --&gt;&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;","link":"/2024/04/devenvcfg/maven/maven-install-cfg/"},{"title":"Linux 新装开发环境初始化","text":"初始配置Ubuntu静态 IP 配置配置静态 IP 地址123456789101112131415cd /etc/netplan# 修改配置文件 00-installer-config.yaml 为以下内容network: version: 2 ethernets: ens33: # 网卡名，通过 ifconfig 查询 dhcp4: no addresses: [192.168.30.252/24] # 静态ip地址/掩码位数 gateway4: 192.168.30.2 # 网关，通过 route -n 查询 nameservers: addresses: [8.8.8.8, 114.114.114.114] # DNS # 应用修改的配置sudo netplan apply 配置国内镜像源24.04 后，Ubuntu 镜像源配置文件路径及方法发生变化，可根据 /etc/apt/sources.list 内的文字描述找到对应位置进行修改。从实际情况来看，默认已配置上清华源，所以当前默认下载速度还算可观。 配置国内镜像源12345678910111213141516171819202122232425# 阿里云 24.04deb https://mirrors.aliyun.com/ubuntu/ noble main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ noble main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ noble-security main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ noble-security main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ noble-updates main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ noble-updates main restricted universe multiverse# deb https://mirrors.aliyun.com/ubuntu/ noble-proposed main restricted universe multiverse# deb-src https://mirrors.aliyun.com/ubuntu/ noble-proposed main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ noble-backports main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ noble-backports main restricted universe multiversesudo cp -a /etc/apt/sources.list /etc/apt/sources.list.baksudo sed -i &quot;s@http://.*archive.ubuntu.com@http://mirrors.aliyun.com@g&quot; /etc/apt/sources.listsudo sed -i &quot;s@http://.*security.ubuntu.com@http://mirrors.aliyun.com@g&quot; /etc/apt/sources.list# 华为云（公共）sudo cp -a /etc/apt/sources.list /etc/apt/sources.list.baksudo sed -i &quot;s@http://.*archive.ubuntu.com@http://mirrors.huaweicloud.com@g&quot; /etc/apt/sources.listsudo sed -i &quot;s@http://.*security.ubuntu.com@http://mirrors.huaweicloud.com@g&quot; /etc/apt/sources.list openEuler静态 IP 配置 获取接口名称 ifconfig：查看已配置的网络接口。 ip addr：显示网络接口的详细信息。 编辑网卡对应的配置文件 1/etc/sysconfig/network-scripts/ifcfg-你的网卡名字 在配置文件中，设置以下参数 12345678910111213141516171819202122232425262728BOOTPROTO=&quot;static&quot;：使用静态IP地址。IPADDR=&quot;你的静态IP地址&quot;：设置您的静态IP地址。NETMASK=&quot;子网掩码&quot;：设置子网掩码。GATEWAY=&quot;网关地址&quot;：设置网关地址。DNS1=&quot;DNS服务器地址&quot;：如果需要，设置DNS服务器地址。ONBOOT=yes：设置网卡在开机时启动。# 一个完整的配置：TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noNAME=ens33UUID=3fae72c0-97d6-4a16-985c-ba32412d18e1DEVICE=ens33ONBOOT=yesIPADDR=192.168.30.128GATEWAY=192.168.30.2NETMASK=255.255.255.0DNS=192.168.30.2DNS2=8.8.8.8 重启网络服务以应用更改 title url linkText1service network restart Fedora静态 IP 配置 查询网卡的uuid 123456sudo nmcli connection show# 示例NAME UUID TYPE DEVICE ens160 efa9002e-e3d0-3b51-ace5-70a172aade97 ethernet ens160 lo 48b9bbc4-117d-4ff4-83d7-020884162259 loopback lo 根据查询结果，配置静态网络 1234sudo nmcli connection modify efa9002e-e3d0-3b51-ace5-70a172aade97 IPv4.address 192.168.3.95/24sudo nmcli connection modify efa9002e-e3d0-3b51-ace5-70a172aade97 IPv4.gateway 192.168.3.1sudo nmcli connection modify efa9002e-e3d0-3b51-ace5-70a172aade97 IPv4.dns 8.8.8.8sudo nmcli connection modify efa9002e-e3d0-3b51-ace5-70a172aade97 IPv4.method manual 重启网络以激活配置 12sudo nmcli connection down efa9002e-e3d0-3b51-ace5-70a172aade97sudo nmcli connection up efa9002e-e3d0-3b51-ace5-70a172aade97 开发环境搭建apt/apt-get 包管理工具开源项目地址：Linux 开发环境一键配置 开发环境搭建脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/bin/bashCUR_DIR=$(pwd)VIM_PLUGIN__PATH=&quot;$HOME/.vim/plugged&quot;VIM_PLUGIN_PREFIX=&quot;vim_plugin_&quot;VIM_PLUGIN_DIR_POSTFIX=&quot;-master&quot;function log_info() { echo &quot;[$(date +'%Y-%m-%d %H:%M:%S')][INFO]: $1&quot;}function log_error() { echo &quot;[$(date +'%Y-%m-%d %H:%M:%S')][ERROR]: $1&quot;}function install_tools() { log_info &quot;Installing tools...&quot; sudo apt update sudo apt install -y \\ vim \\ build-essential \\ gcc \\ g++ \\ cmake \\ make \\ openjdk-21-jdk-headless \\ git \\ flex \\ bison \\ libboost-all-dev \\ libcurl4-openssl-dev \\ libssl-dev \\ libelf-dev\\ libsqlite3-dev \\ pkg-config \\ python3-dev \\ python3-pip \\ dos2unix log_info &quot;Tools installed.&quot;}function install_vim_plugin() { # 安装vim插件 # vim +PlugInstall +qall log_info &quot;Install plugins of vim.&quot; find $CUR_DIR -name &quot;$VIM_PLUGIN_PREFIX*&quot; | xargs -I {} unzip -q {} -d $VIM_PLUGIN__PATH plugin_master_path_lst=$(find $VIM_PLUGIN__PATH -path &quot;*$VIM_PLUGIN_DIR_POSTFIX&quot;) for plugin_master_path in $plugin_master_path_lst; do plugin_path=${plugin_master_path%-*} if [[ ! -e $plugin_path ]]; then mv $plugin_master_path $plugin_path else plugin_name=$(basename $plugin_path) log_info &quot;The plugin has been installed: ${plugin_name}.&quot; rm -rf $plugin_master_path fi done}function config_vim() { log_info &quot;Configuring vim...&quot; # 配置vim cp $CUR_DIR/vimconfig/vimrc.vim ~/.vimrc # 安装vim插件管理器 curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim if [[ $? -ne 0 ]]; then log_info &quot;Failed to install vim-plug and will copy it.&quot; if [[ ! -f ~/.vim/autoload/plug.vim ]]; then mkdir -p ~/.vim/autoload cp $CUR_DIR/vimconfig/plug.vim ~/.vim/autoload/plug.vim fi fi install_vim_plugin vim +LeaderfInstallCExtension log_info &quot;Vim configured.&quot;}function dos_2_unix() { find $CUR_DIR -type f | xargs -I {} dos2unix {} log_info &quot;Converted dos to unix.&quot;}function main() { dos_2_unix install_tools config_vim}main yum/dnf 包管理工具开发环境搭建脚本12345678sudo dnf update#下载所需工具sudo dnf install -y git.x86_64sudo dnf install -y gcc.x86_64sudo dnf install -y cmake.x86_64sudo dnf install -y make.x86_64","link":"/2024/04/devenvcfg/linux/linux-env-init/"},{"title":"Nodejs 安装及初始配置","text":"Nodejs 安装配置安装从 这里 下载 Nodejs 软件包。Windows/Mac 下载对应安装包安装即可。Linux 下载后，解压后的目录放置于想要安装的路径下即可。 配置环境变量配置Linux 1export PATH=$PATH:[nodejs_install_path]/nodejs Windows 123此电脑 &gt; 属性 &gt; 高级系统设置 &gt; 环境变量在系统属性下找到Path，新建，填入安装路径即可。 Mac 安装时相关环境变量已自动配置。 下载配置 配置全局模块下载路径及缓存路径 12npm config set prefix &quot;your_global_module_dir&quot;npm config set cache &quot;your_node_cache_dir&quot; 配置国内镜像源 12345678# 华为开源镜像npm config set registry https://mirrors.huaweicloud.com/repository/npm/# 淘宝npm config set registry https://registry.npm.taobao.org# 阿里npm config set registry https://mirrors.aliyun.com/nodejs-release/","link":"/2024/04/devenvcfg/nodejs/nodejs-install-cfg/"},{"title":"Kotlin 程序设计基础之数据类型及控制流程","text":"数据类型在 Kotlin 中，一切接对象。因此，对于定义的每一个对象，都可以访问该对象上的属性及方法。即使是 Int、Double 等在底层以基本类型所表示的值，在使用时，其行为都表现的跟一个普通的类没有区别。 整形","link":"/2024/03/programinglang/Kotlin/kotlin-basic-grammers/"},{"title":"Docker 镜像操作","text":"什么是镜像镜像操作命令docker image search","link":"/2024/03/container/docker-images-oprator/"},{"title":"React 使用 Effect 同外部系统协作","text":"使用 Effect 同步什么是 EffectReact 组件中常见的两种逻辑类型： 渲染逻辑代码。 位于组件的顶层，在这里接收 props 和 state，并对它们进行转换，最终返回你想在屏幕上看到的 JSX。渲染的代码必须是纯粹的——就像数学公式一样，它只应该“计算”结果，而不做其他任何事情。 事件处理程序。 是嵌套在组件内部的函数，而不仅仅是计算函数。事件处理程序可能会更新输入字段、提交 HTTP POST 请求以购买产品，或者将用户导航到另一个屏幕。事件处理程序包含由特定用户操作（例如按钮点击或键入）引起的“副作用”（它们改变了程序的状态）。 另外一种就是Effect，与前述类型不一样的是，Effect 允许指定由渲染本身，而不是特定事件引起的副作用。在聊天中发送消息是一个“事件”，因为它直接由用户点击特定按钮引起。然而，建立服务器连接是 Effect，因为它应该发生无论哪种交互导致组件出现。Effect 在屏幕更新后的 提交阶段 运行。这是一个很好的时机，可以将 React 组件与某个外部系统（如网络或第三方库）同步。 如何编写 Effect编写 Effect 需要遵循以下三个规则： 声明 Effect。默认情况下，Effect 会在每次渲染后都会执行。 指定 Effect 依赖。大多数 Effect 应该按需执行，而不是在每次渲染后都执行。例如，淡入动画应该只在组件出现时触发。连接和断开服务器的操作只应在组件出现和消失时，或者切换聊天室时执行。 必要时添加清理（cleanup）函数。有时 Effect 需要指定如何停止、撤销，或者清除它的效果。例如，“连接”操作需要“断连”，“订阅”需要“退订”，“获取”既需要“取消”也需要“忽略”。 声明 Effect在 React 中引入 useEffect Hook，并在组件顶部调用它，传入在每次渲染时都需要执行的代码： 声明 effect12345678import { useEffect } from 'react';function MyComponent() { useEffect(() =&gt; { // 每次渲染后都会执行此处的代码 }); return &lt;div /&gt;; } 这样一来，useEffect 会把相应的代码放到每次屏幕更新渲染之后执行。以官方例子为例，考虑一个 &lt;VideoPlayer&gt; React 组件。通过传递布尔类型的 isPlaying prop 以控制是播放还是暂停，VideoPlayer 组件渲染了内置的 &lt;video&gt; 标签，由于浏览器的 &lt;video&gt; 标签没有 isPlaying 属性，而控制它的唯一方式是在 DOM 元素上调用 play() 和 pause() 方法。因此，需要将 isPlaying prop 的值与 play() 和 pause() 等函数的调用进行同步，该属性用于告知当前视频是否应该播放，在这过程中就需要获取 &lt;video&gt; DOM 节点的引用。如果不使用 Effect，试图在渲染期间通过 ref 调用 play() 或 pause() 是达不到目的的： 直接通过 ref 调用 API进行同步12345678910111213141516171819202122232425262728import { useState, useRef, useEffect } from 'react';function VideoPlayer({ src, isPlaying }) { const ref = useRef(null); if (isPlaying) { ref.current.play(); // 渲染期间不能调用 `play()`。 } else { ref.current.pause(); // 同样，调用 `pause()` 也不行。 } return &lt;video ref={ref} src={src} loop playsInline /&gt;;}export default function App() { const [isPlaying, setIsPlaying] = useState(false); return ( &lt;&gt; &lt;button onClick={() =&gt; setIsPlaying(!isPlaying)}&gt; {isPlaying ? '暂停' : '播放'} &lt;/button&gt; &lt;VideoPlayer isPlaying={isPlaying} src=&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4&quot; /&gt; &lt;/&gt; );} 解决办法是 使用 useEffect 包裹副作用，把相应逻辑分离到渲染逻辑的计算过程之外： 通过 Effect 分离同步逻辑12345678910111213import { useEffect, useRef } from 'react'; function VideoPlayer({ src, isPlaying }) { const ref = useRef(null); useEffect(() =&gt; { if (isPlaying) { ref.current.play(); } else { ref.current.pause(); } }); return &lt;video ref={ref} src={src} loop playsInline /&gt;;} 将调用 DOM 方法的操作封装在 Effect 中之后，就可以让 React 先更新屏幕，确定相关 DOM 创建好了以后然后再运行 Effect。这样一来，当 VideoPlayer 组件渲染时（无论是否为首次渲染），React 都会刷新屏幕，确保 &lt;video&gt; 元素已经正确地出现在 DOM 中，然后，运行 Effect，最后，Effect 将根据 isPlaying 的值调用 play() 或 pause()。 指定 Effect 依赖一般来说，Effect 会在 每次 渲染时执行。但更多时候，并不需要每次渲染的时候都执行 Effect。 有时这会拖慢运行速度。因为与外部系统的同步操作总是有一定时耗，在非必要时可能希望跳过它。 有时这会导致程序逻辑错误。例如，组件的淡入动画只需要在第一轮渲染出现时播放一次，而不是每次触发新一轮渲染后都播放。 为了达到这个目的，可以将 依赖数组 传入 useEffect 的第二个参数，以告诉 React 跳过不必要地重新运行 Effect。比如： 传入依赖数组，包含 isPlaying123useEffect(() =&gt; { // ...}, [isPlaying]); 在上述示例中，指定 [isPlaying] 会告诉 React，如果 isPlaying 在上一次渲染时与当前相同，它应该跳过重新运行 Effect。通过这个改变，输入框的输入不会导致 Effect 重新运行，但是按下播放/暂停按钮会重新运行 Effect。依赖数组可以包含多个依赖项。当指定的所有依赖项在上一次渲染期间的值与当前值完全相同时，React 会跳过重新运行该 Effect。React 使用 Object.is 比较依赖项的值。但也 不能随意选择依赖项 。 值得注意的是，没有依赖数组作为第二个参数，与依赖数组位空数组 [] 的行为是不一致的： useEffect 不同依赖数组的差异1234567891011useEffect(() =&gt; { // 这里的代码会在每次渲染后执行});useEffect(() =&gt; { // 这里的代码只会在组件挂载后执行}, []);useEffect(() =&gt; { //这里的代码只会在每次渲染后，并且 a 或 b 的值与上次渲染不一致时执行}, [a, b]); 按需添加清理（cleanup）函数假设想编写一个 ChatRoom 组件，该组件出现时需要连接到聊天服务器。现在已经提供了 createConnection() API，该 API 返回一个包含 connect() 与 disconnection() 方法的对象。这时可以通过如下方式建立链接： 链接聊天室1234useEffect(() =&gt; { const connection = createConnection(); connection.connect(); }, []); Effect 中的代码没有使用任何 props 或 state，此时指定依赖数组为空数组 []。这告诉 React 仅在组件“挂载”时运行此代码，即首次出现在屏幕上这一阶段。但是这样会有个问题：在页面切换后，每次返回聊天室页面，聊天组件都会重新挂载，因此，同一个聊天室将会被重复挂载，中间却从未卸载。为了解决这个问题，可以在 Effect 中返回一个 清理（cleanup） 函数： 从 useEffect 返回清理函数1234567useEffect(() =&gt; { const connection = createConnection(); connection.connect(); return () =&gt; { connection.disconnect(); };}, []); 这样，每次重新执行 Effect 之前，React 都会调用清理函数；组件被卸载时，也会调用清理函数。具体例子如下： 聊天室例子12345678910111213141516171819202122import { useState, useEffect } from 'react';export function createConnection() { // 真实的实现会将其连接到服务器，此处代码只是示例 return { connect() { console.log('✅ 连接中……'); }, disconnect() { console.log('❌ 连接断开。'); } };}export default function ChatRoom() { useEffect(() =&gt; { const connection = createConnection(); connection.connect(); return () =&gt; connection.disconnect(); }, []); return &lt;h1&gt;欢迎来到聊天室！&lt;/h1&gt;;} 为了避免一些不必要的Bug，需要注意使用清理函数机制，使得操作成对出现，例如： 如果 Effect 订阅了某些事件，清理函数应该退订这些事件; 如果 Effect 对某些内容加入了动画，清理函数应将动画重置； 如果 Effect 将会获取数据，清理函数应该要么中止该数据获取操作，要么忽略其结果； 初始化应用时不需要使用 Effect 的情形某些逻辑应该只在应用程序启动时运行一次。比如，验证登陆状态和加载本地程序数据。可以将其放在组件之外： 组件外检查运行一次的状态12345678if (typeof window !== 'undefined') { // 检查是否在浏览器中运行 checkAuthToken(); loadDataFromLocalStorage();}function App() {// ……} 此外，不要在 Effect 中执行购买商品一类的操作，因为，有时即使编写了一个清理函数，也不能避免执行两次 Effect。一方面，开发环境下，Effect 会执行两次，这意味着购买操作执行了两次，但是这并非是预期的结果，所以不应该把这个业务逻辑放在 Effect 中。另一方面，如果用户转到另一个页面，然后按“后退”按钮回到了这个界面，Effect 会随着组件再次挂载而再次执行。故 它不应该写在 Effect 中，应当把 /api/buy 请求操作移动到购买按钮事件处理程序中。 总结Effect 构建了与外部系统交互的桥梁，可以实现渲染后，Dom 节点同系统状态同步的目的，但不能滥用 Effect，并且在处理 Effect 时，应当考虑是否需要借助 useEffect 的清理机制，以在页面刷新获组件卸载时清理相应的资源。","link":"/2024/03/framworks/front_framworks/react/effect-sync-with-external-sys/"},{"title":"React 事件响应及单组件状态处理","text":"事件响应事件处理函数 使用 React 可以在 JSX 中添加 事件处理函数。其中事件处理函数为自定义函数，它将在响应交互（如点击、悬停、表单输入框获得焦点等）时触发。 React 官方文档 – 响应事件 大多元素均可绑定响应的事件，以按钮为例，最常使用的事件为点击事件。在 Ract 中为一个按钮添加点击事件非常简单，只需要在组件内创建一个事件处理函数，并在标签返回时，将其绑定到 onClick 属性上即可： 为按钮绑定点击事件12345678910111213function App() { function handleButtonClick() { alert(&quot;Button clicked.&quot;); } return ( &lt;button onClick={handleButtonClick}&gt; Click me &lt;/button&gt; );}export default App; 事件处理函数通常有如下特点： 通常在 组件内部 定义。（这样做的好处是可以直接访问组件内部的 props 。） 名称以 handle 开头，后跟事件名称。（这只是一种惯例，并非强制。） 一种更为简洁的方式为使用 Javascript 的箭头函数，为一个元素内联绑定事件处理函数，这种方式当处理函数比较小的情况下是非常方便的： 内联函数绑定事件处理1234567891011function App() { return ( &lt;button onClick={()=&gt;{ alert(&quot;Button clicked.&quot;); }}&gt; Click me &lt;/button&gt; );}export default App; 通过 props 传递事件处理函数通常，会在父组件中定义子组件的事件处理函数，这样做提高了子组件的可重用性。例如官网如下示例，根据需要，将不通的事件处理函数传递给按钮组件后，可以实现文件上传、电影点播等不同功能，但是子组件 Button 内部编码却不需要做任何改变。 传递事件处理函数给子组件12345678910111213141516171819202122232425262728293031323334353637 // 定义公共组件，其点击事件在使用时传入function Button({ onClick, children }) { return ( &lt;button onClick={onClick}&gt; {children} // 子组件接收标签内容 &lt;/button&gt; );}function PlayButton({ movieName }) { function handlePlayClick() { alert(`正在播放 ${movieName}！`); } return ( &lt;Button onClick={handlePlayClick}&gt; 播放 &quot;{movieName}&quot; &lt;/Button&gt; );}function UploadButton() { return ( &lt;Button onClick={() =&gt; alert('正在上传！')}&gt; 上传图片 &lt;/Button&gt; );}export default function Toolbar() { return ( &lt;div&gt; &lt;PlayButton movieName=&quot;迪迦奥特曼&quot; /&gt; &lt;UploadButton /&gt; &lt;/div&gt; );} 事件传播行为事件处理函数还会捕获任何来自子组件的事件，即事件从发生的地方开始，沿着 UI 树向上传播。例如： 子组件事件传播行为1234567891011export default function Toolbar() { return ( &lt;div className=&quot;Toolbar&quot; onClick={() =&gt; { alert('你点击了 toolbar ！'); }}&gt; &lt;button onClick={() =&gt; alert('正在播放！')}&gt; 播放电影 &lt;/button&gt; &lt;/div&gt; );} 上述实例中，div 及其子组件 button 均添加了点击事件，虽然行为不同，但是当点击按钮出发其事件处理后，对应的点击事件会沿着UI树向上传播至 div 中，进而触发 div 的点击事件回调其处理函数。所以会看到两次弹窗。但是，这种传播是可以被中断的。每个事件处理函数接收一个 事件对象 作为唯一的参数，可以使用此对象来读取有关事件的信息。同样的，若想阻止事件向上传播，可以在子组件事件处理函数的开始处，借助事件的 e.stopPropagation() 方法实现。（浏览器内置组件可以通过自定义组件来包装一下。） 阻止子组件事件传播行为12345678910function Button({ onClick, children }) { return ( &lt;button onClick={e =&gt; { e.stopPropagation(); // 阻止事件传播至父组件 onClick(); }}&gt; {children} &lt;/button&gt; );} 阻止组件默认行为某些浏览器事件具有与事件相关联的默认行为。例如，点击 &lt;form&gt; 表单内部的按钮会触发表单提交事件，默认情况下将重新加载整个页面，但是这种行为也是可以事件对象的 e.preventDefault() 方法来阻止的： 阻止组件的默认行为1234567891011export default function Signup() { return ( &lt;form onSubmit={e =&gt; { e.preventDefault(); // 阻止组件的默认行为 alert('提交表单！'); }}&gt; &lt;input /&gt; &lt;button&gt;发送&lt;/button&gt; &lt;/form&gt; );} State事件处理函数是执行副作用的最佳位置。同渲染函数不同，事件处理函数不需要是 纯函数，因此它是用来更改某些值的绝佳位置。例如，更改输入框的值以响应键入，或者更改列表以响应按钮的触发。但是，在修改数据前，通常需要记住修改的值，这在 React 中便是通过 State （状态）来实现的。通常情况下，在组件内部使用普通变量保存状态数据后，在事件（例如按钮的点击事件）处理过程中改变其数据后，无法实现新内容的渲染，这是因为： 局部变量无法在多次渲染中持久保存。 当 React 再次渲染组件时，会从头开始渲染，不会考虑之前对局部变量的任何更改。 更改局部变量不会触发渲染。 React 没有意识到它需要使用新数据再次渲染组件。 在 React 中，以上功能可以通过 Hook 函数 useState 实现，该函数接收1个参数，为状态的初始值；返回值可以解构为两个值：其中第一个取值为 状态 ，第二个值为 setter 函数，用于改变状态的取值，进而触发 React 重新渲染组件。 当编写一个存有 state 的组件时，需要考虑使用多少个 state 变量以及它们都是怎样的数据格式。尽管选择次优的 state 结构下也可以编写正确的程序，但有几个原则可以帮助做出更好的决策： 合并关联的 state。如果总是同时更新两个或更多的 state 变量，可以考虑将它们合并为一个单独的 state 变量。 避免互相矛盾的 state。当 state 结构中存在多个相互矛盾或“不一致”的 state 时，就可能为此会留下隐患。应尽量避免这种情况。 避免冗余的 state。如果能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入该组件的 state 中。 避免重复的 state。当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，这会很难保持它们同步。应尽可能减少重复。 避免深度嵌套的 state。深度分层的 state 更新起来不是很方便。如果可能的话，最好以扁平化方式构建 state。 添加一个 state 变量要添加 state 变量，先从文件顶部的 React 中导入 useState： 导入 useState Hook1import { useState } from 'react'; 然后接收 Hook 返回的两个值，这两个取值是相互对应的： 解构 useState 的返回值1const [state, setXxx] = useState(inieState); 官网提供的完整实例如下： 官方示例1234567891011121314151617181920212223242526272829303132333435import { useState } from 'react';import { sculptureList } from './data.js';export default function Gallery() { const [index, setIndex] = useState(0); function handleClick() { // React 会记住中间值 // 即使再次渲染时看到的仍是初始值，但是会使用中间值进行相应的渲染 setIndex(index + 1); } let sculpture = sculptureList[index]; return ( &lt;&gt; &lt;button onClick={handleClick}&gt; Next &lt;/button&gt; &lt;h2&gt; &lt;i&gt;{sculpture.name} &lt;/i&gt; by {sculpture.artist} &lt;/h2&gt; &lt;h3&gt; ({index + 1} of {sculptureList.length}) &lt;/h3&gt; &lt;img src={sculpture.url} alt={sculpture.alt} /&gt; &lt;p&gt; {sculpture.description} &lt;/p&gt; &lt;/&gt; );} Hooks ——以 use 开头的函数——只能在组件或自定义 Hook 的最顶层调用。 你不能在条件语句、循环语句或其他嵌套函数内调用 Hook。Hook 是函数，但将它们视为关于组件需求的无条件声明会很有帮助。在组件顶部 “use” React 特性，类似于在文件顶部“导入”模块。 React 文档 – state 组件的记忆 每个组件可以同时定义多个不同的 state ，不会相互影响。但如果发现经常同时更改多个 state 变量，那么可以由一个值为对象的 state 变量的多个字段对应一个 state 变量，在事件处理过程中，通过更改对象的相应字段即可。 State 是隔离且私有的 State 是屏幕上组件实例内部的状态。换句话说，如果你渲染同一个组件两次，每个副本都会有完全隔离的 state！改变其中一个不会影响另一个。 React 文档 – state 组件的记忆 渲染和提交在 React 中，UI 的更新通常有三个步骤： 触发一次渲染 初次渲染。应用启动时，会触发初次渲染。这个过程通过调用目标 DOM 节点的 createRoot，然后再调用组件调用 render 函数完成。 状态更新时重新渲染。一旦组件被初次渲染，就可以通过使用 setter 函数更新其状态来触发之后的渲染。更新组件的状态会自动将一次渲染送入队列。 set 函数 仅更新 下一次 要渲染的状态变量。如果在调用 setter 函数后读取状态变量，则还是会看到之前的旧值；如果提供的新值与当前 state 相同，则不会触发对应组件及子组件的渲染。 React 渲染组件 在进行初次渲染时, React 会调用根组件。 对于后续的渲染, React 会调用内部状态更新触发了渲染的函数组件。 这个过程是递归的：如果更新后的组件会返回某个另外的组件，那么 React 接下来就会渲染返回的组件，而如果返回的组件又返回了某个组件，那么 React 接下来就会渲染继续渲染后续返回的组件，以此类推。这个过程会持续下去，直到没有更多的嵌套组件并且 React 确切知道哪些东西应该显示到屏幕上为止。 React 把更改提交到 DOM 上 对于初次渲染， React 会使用 appendChild() DOM API 将其创建的所有 DOM 节点放在屏幕上。 对于重渲染， React 将应用最少的必要操作（在渲染时计算。），以使得 DOM 与最新的渲染输出相互匹配。 state 的进一步理解state 如同一张快照 是官方对 state 的一个描述。据此，每次状态变化触发渲染时，渲染的结果都是根据上一次渲染后的结果计算得到。因此，即使在事件处理时多次根据状态的值计算的下一次渲染状态，得到的结果都是相同的。例如： 根据快照 number 计算下一次渲染的结果1234567891011121314151617import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 1); setNumber(number + 1); setNumber(number + 1); }}&gt;+3&lt;/button&gt; &lt;/&gt; )} 上述官方示例中，虽然在按钮的事件处理函数中对 number 状态连续做了三次加一，但是因为都是基于上一次渲染结果的快照（即组件加载时的 0）计算更新，所以最终在下一次渲染时，number 的值为 1，而非 3。另一方面，根据官方文档： 一个 state 变量的值永远不会在一次渲染的内部发生变化， 即使其事件处理函数的代码是异步的。 React 文档 – state 如同一张快照 在一个新的场景下，如果先对状态进行更新，触发组件重新渲染以后，在直接使用对应的状态（例如弹窗显示等），实际上使用的值是上一次渲染的快照值。 渲染组建后随机使用状态做弹窗123456789101112131415import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 5); alert(number); }}&gt;+5&lt;/button&gt; &lt;/&gt; )} 多次更新状态值 React 会等到事件处理函数中的 所有 代码都运行完毕再处理你的 state 更新。 React 文档 – 把一系列 state 更新加入队列 实际上，事件处理函数及其中任何代码执行完成 之后，UI 才会更新，也就是所谓的批处理，这可以保证渲染结果的正确性。在上一节中的示例中，更新状态值都是基于快照的值进行的，而传递给更新函数的都是计算后的值。有时候需要连续多次的对状态的值进行更新，例如，这种场景下，可以传入一个函数给到设值函数，这样一个更新函数接收相应的参数，用于累积结果： 根据更新队列中的值 n，计算后续更新的值12345678910111213141516import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 5); setNumber(n =&gt; n + 1); }}&gt;增加数字&lt;/button&gt; &lt;/&gt; )} 更新 state 中的对象及数组在 React 中，如果状态对应的是一个对象或者数组，如果单纯相应对象的某个属性发生变化，是不会通知到 React 进行重新渲染的。只有通过设值函数利用修改后的 新对象 或者 新数组 更新状态，让 React 感知到相应变化，才能触发组件的重新渲染。总体上，把握一个原则， 不要妄想直接改变原有对象触发渲染，不管什么时候，要想React重新渲染组件，就通过复制或者能够返回一个新对象/数组的函数，传递一个全新的状态至对应状态的设置函数 。例如： 传递一个新的对象，触发渲染并更新红点位置1234567891011121314151617181920212223242526272829303132import { useState } from 'react';export default function MovingDot() { const [position, setPosition] = useState({ x: 0, y: 0 }); return ( &lt;div onPointerMove={e =&gt; { setPosition({ // 传入一个新的对象 x: e.clientX, y: e.clientY }); }} style={{ position: 'relative', width: '100vw', height: '100vh', }}&gt; &lt;div style={{ position: 'absolute', backgroundColor: 'red', borderRadius: '50%', transform: `translate(${position.x}px, ${position.y}px)`, left: -10, top: -10, width: 20, height: 20, }} /&gt; &lt;/div&gt; );} 如果对象比较复杂，可以使用 展开语法 进行对象复制： 展开语法复制对象/数组1234567891011// 复制对象setPerson({ ...person, // 复制上一个 person 中的所有字段 firstName: e.target.value // 但是覆盖 firstName 字段 });// 复制数组setArtists([{ id: nextId++, name: name }, ...artists // 将原数组中的元素放在末尾 ]); 如果对象比较复杂，数据一些逻辑较为啰嗦，可以利用 Immer 库简化相应的更新操作。添加相应的依赖： immer 依赖12345678910111213141516{ &quot;dependencies&quot;: { &quot;immer&quot;: &quot;1.7.3&quot;, &quot;react&quot;: &quot;latest&quot;, &quot;react-dom&quot;: &quot;latest&quot;, &quot;react-scripts&quot;: &quot;latest&quot;, &quot;use-immer&quot;: &quot;0.5.1&quot; }, &quot;scripts&quot;: { &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; }, &quot;devDependencies&quot;: {}} Immer 使用举例： Immer 用法123456789101112131415161718192021222324252627282930313233343536373839import { useState } from 'react';import { useImmer } from 'use-immer';const initialList = [ { id: 0, title: 'Big Bellies', seen: false }, { id: 1, title: 'Lunar Landscape', seen: false }, { id: 2, title: 'Terracotta Army', seen: true },];...export default function BucketList() { const [myList, updateMyList] = useImmer( initialList ); function handleToggleMyList(id, nextSeen) { updateMyList(draft =&gt; { const artwork = draft.find(a =&gt; a.id === id ); artwork.seen = nextSeen; }); } return ( &lt;&gt; &lt;h1&gt;艺术愿望清单&lt;/h1&gt; &lt;h2&gt;我想看的艺术清单：&lt;/h2&gt; &lt;ItemList artworks={myList} onToggle={handleToggleMyList} /&gt; &lt;h2&gt;你想看的艺术清单：&lt;/h2&gt; &lt;ItemList artworks={yourList} onToggle={handleToggleYourList} /&gt; &lt;/&gt; );}...","link":"/2024/03/framworks/front_framworks/react/event-response-and-single-comp-state/"},{"title":"React Ref 建立虚拟与真实Dom的链接","text":"使用 ref 引用值当希望组件“记住”某些信息，但又不想让这些信息触发新的渲染时，可以使用 ref 来实现。使用时，可以通过从 React 导入 useRef Hook 来为组件添加一个 ref： 为组件创建 ref12345678import { useRef } from 'react';const ref = useRef(0);// 此 Hook 返回一个对象，其中保存传入的取值{ current: 0} 之后，就可以使用 ref.current 属性访问该 ref 的当前值。这个值在 React 中被有意设置为可变的，意味着可以对它进行读写操作。像 state 一样，可以让它指向任何东西：字符串、对象，甚至是函数。但与 state 不同的是，ref 是一个普通的 JavaScript 对象，并且在 ref 值更新时，组件不会被重新渲染。因此，如果在更新取值后，若需要重新渲染组件才会显示新状态的场景，ref 并不是一个合适的选择，因为界面永远不会被刷新。 ref 和 state 的比较在大多数情况下，React 官方建议使用 state，ref 并不常用。 ref state useRef(initialValue)返回 { current: initialValue } useState(initialValue) 返回 state 变量的当前值和一个 state 设置函数 ( [value, setValue]) 更改时不会触发重新渲染 更改时触发重新渲染。 可变 —— 可以在渲染过程之外修改和更新 current 的值。 “不可变” —— 必须使用 state 设置函数来修改 state 变量，从而排队重新渲染。 不应在渲染期间读取（或写入） current 值。 可以随时读取 state。但是，每次渲染都有自己不变的 state 快照。 何时使用 ref通常，当组件需要“跳出” React 并与外部 API 通信时，会用到 ref —— 通常是不会影响组件外观的浏览器 API。以下是这些罕见情况中的几个： 存储 timeout ID 存储和操作DOM 元素 存储不需要被用来计算 JSX 的其他对象。 如果组件需要存储一些值，但不影响渲染逻辑，可以选择 ref。 ref 的最佳实践 将 ref 视为脱围机制。当使用外部系统或浏览器 API 时，ref 很有用。如果很大一部分应用程序逻辑和数据流都依赖于 ref，则可能需要重新考虑实现的方法。 不要在渲染过程中读取或写入 ref.current。 如果渲染过程中需要某些信息，请使用 state 代替。由于 React 不知道 ref.current 何时发生变化，即使在渲染时读取它也会使组件的行为难以预测。（唯一的例外是像 if (!ref.current) ref.current = new Thing() 这样的代码，它只在第一次渲染期间设置一次 ref。） 使用 ref 操作 Domref 最常见的用法是访问 DOM 元素，例如，如果想以编程方式聚焦一个输入框，这种用法就会派上用场。当将 ref 传递给 JSX 中的 ref 属性时，比如 &lt;div ref={myRef}&gt;，React 会将相应的 DOM 元素放入 myRef.current 中。当元素从 DOM 中删除时，React 会将 myRef.current 更新为 null。下面总结如何使用 ref 来操作 Dom。 获取指向 Dom 节点的 ref想要获取只想 Dom 节点的 ref 很简单，只需要将声明的 ref 作为 ref 属性值传递给想要获取的 DOM 节点的 HTML 标准 JSX 标签即可： 获取指向 div 节点的 ref1234import { useRef } from 'react';const myRef = useRef(null);&lt;div ref={myRef}&gt; 当 React 为这个 &lt;div&gt; 创建好 DOM 节点时，React 会把对该节点的引用放入 myRef.current 中，然后就可以从事件处理器函数访问此 DOM 节点，并调用在其上定义的内置浏览器API了。例如： 获取指向 input 节点的 ref123456789101112131415161718import { useRef } from 'react';export default function Form() { const inputRef = useRef(null); function handleClick() { inputRef.current.focus(); } return ( &lt;&gt; &lt;input ref={inputRef} /&gt; &lt;button onClick={handleClick}&gt; 聚焦输入框 &lt;/button&gt; &lt;/&gt; );} 在上述示例中，在获取到 input 节点的 ref 后，通过 button 的事件处理函数 handleClick 调用 inputRef.current.focus()，实现对输入框的聚焦。 访问另一个组件的 DOM 节点如果尝试将 ref 放在 自己定义组件 上，例如 &lt;MyInput /&gt;，默认情况下会得到 null ，这是因为 React 不允许组件访问其他组件的 DOM 节点。但也不是就没有办法实现访问其他组件中的 Dom 节点，这时需要想要暴露其 DOM 节点的组件必须选择实现该行为。一个组件可以指定将它的 ref “转发”给一个子组件。例如 MyInput 使用 forwardRef API 进行 ref 转发： ref 转发123const MyInput = forwardRef((props, ref) =&gt; { return &lt;input {...props} ref={ref} /&gt;; }); 这时候： &lt;MyInput ref={inputRef} /&gt; 告诉 React 将对应的 DOM 节点放入 inputRef.current 中。但是，这取决于 MyInput 组件是否允许这种行为， 默认情况下是不允许的。 MyInput 组件是使用 forwardRef 声明的。 这让从上面接收的 inputRef 作为第二个参数 ref 传入组件，第一个参数是 props 。 MyInput 组件将自己接收到的 ref 传递给它内部的 &lt;input&gt;。 完整的例子： ref 转发完整示例12345678910111213141516171819202122import { forwardRef, useRef } from 'react';const MyInput = forwardRef((props, ref) =&gt; { return &lt;input {...props} ref={ref} /&gt;;});export default function Form() { const inputRef = useRef(null); function handleClick() { inputRef.current.focus(); } return ( &lt;&gt; &lt;MyInput ref={inputRef} /&gt; &lt;button onClick={handleClick}&gt; 聚焦输入框 &lt;/button&gt; &lt;/&gt; );} React 何时添加 refs在 React 中，每次更新都分为 两个阶段： 在 渲染 阶段， React 调用组件来确定屏幕上应该显示什么。 在 提交 阶段， React 把变更应用于 DOM。 通常，在第一次渲染期间，DOM 节点尚未创建，因此 ref.current 将为 null，在渲染更新的过程中，DOM 节点还没有更新。因此，React 在提交阶段设置 ref.current。在更新 DOM 之前，React 将受影响的 ref.current 值设置为 null。更新 DOM 后，React 立即将它们设置到相应的 DOM 节点。一般情况下，从事件处理器访问 refs 即可，但并非所有想要访问 Dom 节点的操作都可以有对应的事件处理函数来处理，这时可以借助 Effect 实现，在下一章中会进行总结。 另一方面，使用 ref 时，应避免更改由 React 管理的 DOM 节点 。对 React 管理的元素进行修改、添加子元素、从中删除子元素会导致不一致的视觉结果，甚至是崩溃。不过，可以安全地修改 React 没有理由更新的部分 DOM。 例如，如果某些 &lt;div&gt; 在 JSX 中始终为空，React 将没有理由去变动其子列表。 因此，在那里手动增删元素是安全的。 总结使用 ref，可以在不触发重新渲染的情况下，记住某些变量值，最有用的点是可以使 ref 指向 Dom 节点，进而直接使用浏览器API，实现一些特殊的效果。","link":"/2024/03/framworks/front_framworks/react/ref-bridge-between-virtual-real-dom/"},{"title":"React 利用Reducer管理复杂状态及Context深层传递状态","text":"迁移状态逻辑至 Reducer 中随着组件复杂度的增加，将很难一眼看清所有的组件状态更新逻辑。例如，下面的 TaskApp 组件有一个数组类型的状态 tasks，并通过三个不同的事件处理程序来实现任务的添加、删除和修改： 多事件处理程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import { useState } from 'react';import AddTask from './AddTask.js';import TaskList from './TaskList.js';export default function TaskApp() { const [tasks, setTasks] = useState(initialTasks); function handleAddTask(text) { setTasks([ ...tasks, { id: nextId++, text: text, done: false, }, ]); } function handleChangeTask(task) { setTasks( tasks.map((t) =&gt; { if (t.id === task.id) { return task; } else { return t; } }) ); } function handleDeleteTask(taskId) { setTasks(tasks.filter((t) =&gt; t.id !== taskId)); } return ( &lt;&gt; &lt;h1&gt;布拉格的行程安排&lt;/h1&gt; &lt;AddTask onAddTask={handleAddTask} /&gt; &lt;TaskList tasks={tasks} onChangeTask={handleChangeTask} onDeleteTask={handleDeleteTask} /&gt; &lt;/&gt; );}let nextId = 3;const initialTasks = [ {id: 0, text: '参观卡夫卡博物馆', done: true}, {id: 1, text: '看木偶戏', done: false}, {id: 2, text: '打卡列侬墙', done: false},]; 这个组件的每个事件处理程序都通过 setTasks 来更新状态。随着这个组件的不断迭代，其状态逻辑也会越来越多。为了降低这种复杂度，并让所有逻辑都可以存放在一个易于理解的地方，可以通过三个步骤将逻辑移到组件之外的一个称为 reducer 的函数中（useReducer）： 将设置状态的逻辑 修改 成 dispatch 的一个 action 编写 一个 reducer 函数 在组件中 使用 reducer 将设置状态的逻辑修改分派方式移除所有的状态设置逻辑。只留下三个事件处理函数： handleAddTask(text) 在用户点击 “添加” 时被调用。 handleChangeTask(task) 在用户切换任务或点击 “保存” 时被调用。 handleDeleteTask(taskId) 在用户点击 “删除” 时被调用。 使用 reducers 管理状态与直接设置状态略有不同。它不是通过设置状态来告诉 React “要做什么”，而是通过事件处理程序分派一个带着不同行为的 Flag 来指明 “用户刚刚做了什么”，以及如何处理该事件。 事件处理程序分派123456789101112131415161718192021function handleAddTask(text) { dispatch({ type: 'added', id: nextId++, text: text, }); } function handleChangeTask(task) { dispatch({ type: 'changed', task: task, }); } function handleDeleteTask(taskId) { dispatch({ type: 'deleted', id: taskId, }); } 编写一个 reducer 函数所谓 reducer 函数就是放置状态处理逻辑的地方。它接受两个参数，分别为当前 state 和 action 对象，并且返回的是更新后的 state。React 会将状态设置为从 reducer 返回的状态。在当前例子中，可以通过如下步骤将状态设置逻辑从事件处理程序移到 reducer 函数中： 声明当前状态（tasks）作为第一个参数； 声明 action 对象作为第二个参数； 从 reducer 返回 下一个 状态（React 会将旧的状态设置为这个最新的状态）。 事件分派123456789101112131415161718192021222324function tasksReducer(tasks, action) { if (action.type === 'added') { return [ ...tasks, { id: action.id, text: action.text, done: false, }, ]; } else if (action.type === 'changed') { return tasks.map((t) =&gt; { if (t.id === action.task.id) { return action.task; } else { return t; } }); } else if (action.type === 'deleted') { return tasks.filter((t) =&gt; t.id !== action.id); } else { throw Error('未知 action: ' + action.type); } } 在组件中使用 reducer最后，需要将 tasksReducer 导入到组件中。以替换掉之前的 useState： 使用 reducer123456import { useReducer } from 'react';// 删除状态const [tasks, setTasks] = useState(initialTasks);// 改用 reducerconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks); 使用 useReducer时，必须给它传递一个初始状态，它会返回一个有状态的值和一个设置该状态的函数（在这个例子中就是 dispatch 函数）。useReducer 钩子接受 2 个参数： 一个 reducer 函数 一个初始的 state 然后返回如下内容： 一个有状态的值 一个 dispatch 函数（用来 “派发” 用户操作给 reducer） 这样，事件处理程序只通过派发不同的 action 来指定 发生了什么，而 reducer 函数通过响应不同的 actions 来决定 状态如何更新。 对比 useState 和 useReducer 代码体积： 通常，在使用 useState 时，一开始只需要编写少量代码。而 useReducer 必须提前编写 reducer 函数和需要调度的 actions。但是，当多个事件处理程序以相似的方式修改 state 时，useReducer 可以减少代码量。 可读性： 当状态更新逻辑足够简单时，useState 的可读性还行。但是，一旦逻辑变得复杂起来，它们会使组件变得臃肿且难以阅读。在这种情况下，useReducer 允许将状态更新逻辑与事件处理程序分离开来。 可调试性： 当使用 useState 出现问题时, 很难发现具体原因以及为什么。 而使用 useReducer 时， 可以在 reducer 函数中通过打印日志的方式来观察每个状态的更新，以及为什么要更新（来自哪个 action）。 如果所有 action 都没问题，就知道问题出在了 reducer 本身的逻辑中。 然而，与使用 useState 相比，必须单步执行更多的代码。 可测试性： reducer 是一个不依赖于组件的纯函数。这就意味着可以单独对它进行测试。一般来说，最好是在真实环境中测试组件，但对于复杂的状态更新逻辑，针对特定的初始状态和 action，断言 reducer 返回的特定状态会很有帮助。 如何编写一个好的 reducers reducers 必须是纯粹的。 这一点和状态更新函数是相似的，reducers 在是在渲染时运行的！（actions 会排队直到下一次渲染)。 这就意味着 reducers 必须无副作用，即当输入相同时，输出也是相同的。它们不应该包含异步请求、定时器或者任何副作用（对组件外部有影响的操作）。它们应该以不可变值的方式去更新对象和数组。 每个 action 都描述了一个单一的用户交互，即使它会引发数据的多个变化。 举个例子，如果用户在一个由 reducer 管理的表单（包含五个表单项）中点击了 重置按钮，那么 dispatch 一个 reset_form 的 action 比 dispatch 五个单独的 set_field 的 action 更加合理。如果在一个 reducer 中打印了所有的 action 日志，那么这个日志应该是很清晰的，它能以某种步骤复现已发生的交互或响应。这对代码调试很有帮助。 使用 Context 深层传递参数传递 props 是将数据通过 UI 树显式传递到使用它的组件的常用方法，但是当需要在组件树中深层传递参数以及需要在组件间复用相同的参数时，传递 props 就会变得很麻烦。最近的根节点父组件可能离需要数据的组件很远，状态提升到太高的层级会导致 “逐层传递 props” 的情况。 此时，利用 Context 允许父组件向其下层无论多深的任何组件提供信息，而无需通过 props 显式传递。 Context：传递 propsContext 让父组件可以为它下面的整个组件树提供数据。官网示例主题App如下： Context示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import Heading from './Heading.js';import Section from './Section.js';export default function Page() { return ( &lt;Section&gt; &lt;Heading level={1}&gt;主标题&lt;/Heading&gt; &lt;Section&gt; &lt;Heading level={2}&gt;副标题&lt;/Heading&gt; &lt;Heading level={2}&gt;副标题&lt;/Heading&gt; &lt;Heading level={2}&gt;副标题&lt;/Heading&gt; &lt;Section&gt; &lt;Heading level={3}&gt;子标题&lt;/Heading&gt; &lt;Heading level={3}&gt;子标题&lt;/Heading&gt; &lt;Heading level={3}&gt;子标题&lt;/Heading&gt; &lt;Section&gt; &lt;Heading level={4}&gt;子子标题&lt;/Heading&gt; &lt;Heading level={4}&gt;子子标题&lt;/Heading&gt; &lt;Heading level={4}&gt;子子标题&lt;/Heading&gt; &lt;/Section&gt; &lt;/Section&gt; &lt;/Section&gt; &lt;/Section&gt; );}export function Section({ children }) { return ( &lt;section className=&quot;section&quot;&gt; {children} &lt;/section&gt; );}export function Heading({ level, children }) { switch (level) { case 1: return &lt;h1&gt;{children}&lt;/h1&gt;; case 2: return &lt;h2&gt;{children}&lt;/h2&gt;; case 3: return &lt;h3&gt;{children}&lt;/h3&gt;; case 4: return &lt;h4&gt;{children}&lt;/h4&gt;; case 5: return &lt;h5&gt;{children}&lt;/h5&gt;; case 6: return &lt;h6&gt;{children}&lt;/h6&gt;; default: throw Error('未知的 level：' + level); }} 此示例可以改为将 level 参数传递给 &lt;Section&gt; 组件而不是传给 &lt;Heading&gt; 组件，以强制使同一个 section 中的所有标题都有相同的尺寸： 状态提升12345&lt;Section level={3}&gt; &lt;Heading&gt;关于&lt;/Heading&gt; &lt;Heading&gt;照片&lt;/Heading&gt; &lt;Heading&gt;视频&lt;/Heading&gt; &lt;/Section&gt; 但是当 Section 组件嵌套使用并且不同层级下的标题有不同的级别时，就需要知道离 Heading 最近的 Section 是谁才能够实现目的，这就可以通过 context 来实现： 创建 一个 context。（可以将其命名为 LevelContext, 因为它表示的是标题级别。) 在需要数据的组件内 使用 刚刚创建的 context。（Heading 将会使用 LevelContext。） 在指定数据的组件中 提供 这个 context。 （Section 将会提供 LevelContext。） 这样，Context 可以让父节点，甚至是很远的父节点都可以为其内部的整个组件树提供数据： 创建 context首先，创建 context： Context 创建123import { createContext } from 'react';export const LevelContext = createContext(1); createContext 只需默认值一个参数。在这里, 1 表示最大的标题级别，但可以传递任何类型的值（甚至可以传入一个对象）。 使用 Context然后，从 Heading 组件的 props 中删掉 level 参数并从 LevelContext 中读取值： 从 Context 中读取值12345export default function Heading({ children }) { const level = useContext(LevelContext); // ... } useContext 是一个 Hook，只能在 React 组件中（不是循环或者条件里）立即调用 Hook。**useContext 告诉 React Heading 组件想要读取 LevelContext**。如此一来 Heading 组件就无需传递 level 参数，而是让 Section 组件代替 Heading 组件接收 level 参数： 通过 Section 接收 level 参数12345&lt;Section level={4}&gt; &lt;Heading&gt;子子标题&lt;/Heading&gt; &lt;Heading&gt;子子标题&lt;/Heading&gt; &lt;Heading&gt;子子标题&lt;/Heading&gt; &lt;/Section&gt; 提供 context最后，需要提供正在使用 context，因为当前 React 还不知道从哪里获取这个 context。Section 组件目前渲染传入它的子组件： Section渲染子组件1234567export default function Section({ children }) { return ( &lt;section className=&quot;section&quot;&gt; {children} &lt;/section&gt; ); } 需要用 context provider 将子组件包裹起来以提供 LevelContext 给 Section 的子组件： 为子组件提供 Context123456789export function Section({ level, children }) { return ( &lt;section className=&quot;section&quot;&gt; &lt;LevelContext.Provider value={level}&gt; {children} &lt;/LevelContext.Provider&gt; &lt;/section&gt; ); } 这告诉 React：“如果在 &lt;Section&gt; 组件中的任何子组件请求 LevelContext，则给他们这个 level。” 组件会使用 UI 树中在它上层最近的那个 &lt;LevelContext.Provider&gt; 传递过来的值。此外，可以在提供 context 的组件和使用它的组件之间的层级插入任意数量的组件。这包括像 &lt;div&gt; 这样的内置组件和自己创建的组件。 使用 context 之前 从传递 props 开始。 如果组件看起来不起眼，那么通过十几个组件向下传递一堆 props 并不罕见。这有点像是在埋头苦干，但是这样做可以让哪些组件用了哪些数据变得十分清晰！ 抽象组件并将 JSX 作为 children 传递 给它们。 如果通过很多层不使用该数据的中间组件（并且只会向下传递）来传递数据，这通常意味着在此过程中可以使用抽象组件。举个例子，有时可能想传递一些像 posts 的数据 props 到不会直接使用这个参数的组件，类似 &lt;Layout posts={posts} /&gt;。取而代之的是，让 Layout 把 children 当做一个参数，然后渲染 &lt;Layout&gt;&lt;Posts posts={posts} /&gt;&lt;/Layout&gt;。这样就减少了定义数据的组件和使用数据的组件之间的层级。 Context 的使用场景 主题： 如果应用允许用户更改其外观（例如暗夜模式），可以在应用顶层放一个 context provider，并在需要调整其外观的组件中使用该 context。 当前账户： 许多组件可能需要知道当前登录的用户信息。将它放到 context 中可以方便地在树中的任何位置读取它。某些应用还允许同时操作多个账户（例如，以不同用户的身份发表评论）。在这些情况下，将 UI 的一部分包裹到具有不同账户数据的 provider 中会很方便。 路由： 大多数路由解决方案在其内部使用 context 来保存当前路由。这就是每个链接“知道”它是否处于活动状态的方式。 状态管理： 随着应用的增长，最终在靠近应用顶部的位置可能会有很多 state。许多遥远的下层组件可能想要修改它们。通常将 reducer 与 context 搭配使用来管理复杂的状态并将其传递给深层的组件来避免过多的麻烦。 总结在组件状态较为复杂时，可以通过 Reducer 整合相近行为的事件处理函数，通过事件分派的方式，减少需要管理的状态个数。如果需要远距离向下共享状态，则可以通过 Context 实现。","link":"/2024/03/framworks/front_framworks/react/reducer-state-mgr-and-context/"},{"title":"React 在组件间共享状态","text":"状态共享的一个例子要实现两个组件的状态始终同步更改，可以将相关 state 从这两个组件上移除，并把 state 放到它们的公共父级，再通过 props 将 state 传递给这两个组件。这个操作被称为“状态提升”。共享状态的场景在前端开发中非常常见，这里整理官网提供的状态提升示例，进一步巩固状态提升的掌握。示例如下： 状态提升前1234567891011121314151617181920212223242526272829303132import { useState } from 'react';function Panel({ title, children }) { const [isActive, setIsActive] = useState(false); return ( &lt;section className=&quot;panel&quot;&gt; &lt;h3&gt;{title}&lt;/h3&gt; {isActive ? ( &lt;p&gt;{children}&lt;/p&gt; ) : ( &lt;button onClick={() =&gt; setIsActive(true)}&gt; 显示 &lt;/button&gt; )} &lt;/section&gt; );}export default function Accordion() { return ( &lt;&gt; &lt;h2&gt;哈萨克斯坦，阿拉木图&lt;/h2&gt; &lt;Panel title=&quot;关于&quot;&gt; 阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。 &lt;/Panel&gt; &lt;Panel title=&quot;词源&quot;&gt; 这个名字来自于 &lt;span lang=&quot;kk-KZ&quot;&gt;алма&lt;/span&gt;，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，&lt;i lang=&quot;la&quot;&gt;Malus sieversii&lt;/i&gt; 被认为是现今苹果的祖先。 &lt;/Panel&gt; &lt;/&gt; );} 上述示例中，父组件 Accordion 渲染了 2 个独立的 Panel 组件，每个 Panel 组件都有一个布尔值 isActive，用于独立的控制组件自己的内容是否可见。假设想改变这种行为，以便在任何时候只展开一个面板。这个时候，isActive 就不能放置于组件自身，需要将其提升至父组件中，以便可以将 isActive 状态共享给两个子组件。这可以通过如下三步实现： 从子组件中 移除 state 。 从父组件 传递 硬编码数据。 为共同的父组件添加 state ，并将其与事件处理函数一起向下传递。 从子组件中移除状态首先，将 Panel 组件对 isActive 的控制权交给他们的父组件，由父组件将 isActive 作为 prop 传给子组件 Panel。因此，先从 Panel 组件中删除 isActive 状态，并把 isActive 加入 Panel 组件的 props 中： 移除子组件 isActive 状态12345// 从子组件中删除这一行const [isActive, setIsActive] = useState(false);// 子组件的 props 中加入 isActivefunction Panel({ title, children, isActive }){ ... } 从公共父组件传递硬编码数据然后，为了实现状态提升，须定位到想协调的两个子组件最近的公共父组件： Accordion (最近的公共父组件) Panel Panel 在这个示例中，最近的公共父组件是 Accordion。因为它位于两个面板之上，可以控制两个子组件的 props，所以它将成为当前激活面板的“控制之源”。这里通过 Accordion 组件将 isActive 硬编码值（例如 true ）传递给两个面板，可以看到不同取值下两个子组件的行为： 传递 isActive 的硬编码状态给两个子组件123456789101112131415161718192021222324252627282930import { useState } from 'react';export default function Accordion() { return ( &lt;&gt; &lt;h2&gt;哈萨克斯坦，阿拉木图&lt;/h2&gt; &lt;Panel title=&quot;关于&quot; isActive={true}&gt; 阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。 &lt;/Panel&gt; &lt;Panel title=&quot;词源&quot; isActive={true}&gt; 这个名字来自于 &lt;span lang=&quot;kk-KZ&quot;&gt;алма&lt;/span&gt;，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，&lt;i lang=&quot;la&quot;&gt;Malus sieversii&lt;/i&gt; 被认为是现今苹果的祖先。 &lt;/Panel&gt; &lt;/&gt; );}function Panel({ title, children, isActive }) { return ( &lt;section className=&quot;panel&quot;&gt; &lt;h3&gt;{title}&lt;/h3&gt; {isActive ? ( &lt;p&gt;{children}&lt;/p&gt; ) : ( &lt;button onClick={() =&gt; setIsActive(true)}&gt; 显示 &lt;/button&gt; )} &lt;/section&gt; );} 为公共父组件添加状态状态提升通常会改变原状态的数据存储类型，以便子组件更加精确的识别想要的行为，但是改变并不是必须的，本示例就是如此。但在官网的示例中，改用数字作为当前被激活 Panel 的索引，而不是 boolean 值，即当 activeIndex 为 0 时，激活第一个面板，为 1 时，激活第二个面板。另一方面，在任意一个 Panel 中点击“显示”按钮都需要更改 Accordion 中的激活索引值。但在 Panel 中无法直接设置状态 activeIndex 的值，因为该状态是在 Accordion 组件内部定义的。不过Accordion 组件需要可以 显式允许 Panel 组件通过 将事件处理程序作为 prop 向下传递 来更改其状态父组件中的状态： 父组件传递共享 isActive 状态及设值函数123456789101112131415161718192021222324252627282930313233343536373839404142434445import { useState } from 'react';export default function Accordion() { const [activeIndex, setActiveIndex] = useState(0); return ( &lt;&gt; &lt;h2&gt;哈萨克斯坦，阿拉木图&lt;/h2&gt; &lt;Panel title=&quot;关于&quot; isActive={activeIndex === 0} onShow={() =&gt; setActiveIndex(0)} &gt; 阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。 &lt;/Panel&gt; &lt;Panel title=&quot;词源&quot; isActive={activeIndex === 1} onShow={() =&gt; setActiveIndex(1)} &gt; 这个名字来自于 &lt;span lang=&quot;kk-KZ&quot;&gt;алма&lt;/span&gt;，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，&lt;i lang=&quot;la&quot;&gt;Malus sieversii&lt;/i&gt; 被认为是现今苹果的祖先。 &lt;/Panel&gt; &lt;/&gt; );}function Panel({ title, children, isActive, onShow}) { return ( &lt;section className=&quot;panel&quot;&gt; &lt;h3&gt;{title}&lt;/h3&gt; {isActive ? ( &lt;p&gt;{children}&lt;/p&gt; ) : ( &lt;button onClick={onShow}&gt; 显示 &lt;/button&gt; )} &lt;/section&gt; );} 每个状态都对应唯一的数据源需要注意的是：对于每个独特的状态，都应该存在且只存在于一个指定的组件中作为 state。这一原则也被称为拥有 “可信单一数据源”。它并不意味着所有状态都存在一个地方——对每个状态来说，都需要一个特定的组件来保存这些状态信息。应该 将状态提升 到公共父级，或 将状态传递 到需要它的子级中，而不是在组件之间复制共享的状态。此外，应用会随着操作而变化。当将状态上下移动时，依然会需要确定每个状态在哪里“活跃”。 state 的保留和重置状态与渲染树中的位置相关虽说各个组件的 state 是各自独立的，但是这些状态是保存在 React 中的，React 可以跟踪组件在渲染树中的位置将它保存的每个状态与正确的组件关联起来。开发过程中，可以控制在重新渲染过程中何时对 state 进行保留和重置。例如： 组件状态与位置12345678910111213141516171819202122232425262728293031323334import { useState } from 'react';export default function App() { const counter = &lt;Counter /&gt;; return ( &lt;div&gt; {counter} {counter} &lt;/div&gt; );}function Counter() { const [score, setScore] = useState(0); const [hover, setHover] = useState(false); let className = 'counter'; if (hover) { className += ' hover'; } return ( &lt;div className={className} onPointerEnter={() =&gt; setHover(true)} onPointerLeave={() =&gt; setHover(false)} &gt; &lt;h1&gt;{score}&lt;/h1&gt; &lt;button onClick={() =&gt; setScore(score + 1)}&gt; 加一 &lt;/button&gt; &lt;/div&gt; );} 在上述示例代码中，两个 counter 对象被先后两次渲染，尽管看上去是同一个对象，但是在 UI 树中，可以理解为原始对象的副本，而对应节点的状态则是由位置决定，React 根据位置关联对应的组件虚拟 Dom。前面文章提到过，状态是相互隔离的。因此，在此例子中，若点击各自组件的计数按钮，会发现两个组件计数器独自变化。下图为部分 UI 树： 此外，只有当在树中相同的位置渲染相同的组件时，React 才会一直保留着组件的 state。可以增加一个复选框，控制第二个计数器的是否渲染，将两个计数器的值递增，然后取消勾选 “渲染第二个计数器” 复选框，接着再次勾选它。可以发现，第二个组件的计数在重新勾选后，会从0开始。 增加复选框控制第二个组件渲染1234567891011121314151617181920export default function App() { const [showB, setShowB] = useState(true); return ( &lt;div&gt; &lt;Counter /&gt; {showB &amp;&amp; &lt;Counter /&gt;} &lt;label&gt; &lt;input type=&quot;checkbox&quot; checked={showB} onChange={e =&gt; { setShowB(e.target.checked) }} /&gt; 渲染第二个计数器 &lt;/label&gt; &lt;/div&gt; );}... 相同位置的相同组件会使得 state 被保留下来不过有一点乍一看可能与上述描述不一致，第一个组件如果被再次被渲染，只要该组件还被渲染在 UI 树的相同位置，React 就会保留它的 state。 这个相同位置指的是其在UI树中的位置，与在 jsx 代码中的位置无关。举个例子： 两个组件在同一位置被渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import { useState } from 'react';export default function App() { const [isFancy, setIsFancy] = useState(false); return ( &lt;div&gt; {isFancy ? ( &lt;Counter isFancy={true} /&gt; ) : ( &lt;Counter isFancy={false} /&gt; )} &lt;label&gt; &lt;input type=&quot;checkbox&quot; checked={isFancy} onChange={e =&gt; { setIsFancy(e.target.checked) }} /&gt; 使用好看的样式 &lt;/label&gt; &lt;/div&gt; );}function Counter({ isFancy }) { const [score, setScore] = useState(0); const [hover, setHover] = useState(false); let className = 'counter'; if (hover) { className += ' hover'; } if (isFancy) { className += ' fancy'; } return ( &lt;div className={className} onPointerEnter={() =&gt; setHover(true)} onPointerLeave={() =&gt; setHover(false)} &gt; &lt;h1&gt;{score}&lt;/h1&gt; &lt;button onClick={() =&gt; setScore(score + 1)}&gt; 加一 &lt;/button&gt; &lt;/div&gt; );} 当勾选或清空复选框的时候，计数器 state 并没有被重置。不管 isFancy 是 true 还是 false，根组件 App 返回的 div 的第一个子组件都是 &lt;Counter /&gt;，因为是位于相同位置的相同组件，所以对 React 来说，它是同一个计数器。这也就是说，在UI树中相同位置，渲染同类型组件，就会被视为同一个组件被渲染，同时相应的状态得以保留。与之不同的是，如果在相同位置渲染不同类型组件，则会使 state 重置，包括该组件的整个子树都会被重置 。一般来说，如果想在重新渲染时保留 state，几次渲染中的树形结构就应该相互“匹配”。结构不同会 React 在将一个组件从树中移除时销毁它的 state。因此，永远要将组件定义在最上层，并且在组件内部嵌套定义组件 。 在相同位置重置 state默认情况下，React 会在一个组件保持在同一位置时保留它的 state。但有时候，可能想要重置一个组件的 state。这里有两个方法可以实现重置 state： 将组件渲染在不同的位置（界面显示效果，实际在UI树中可能为左右不同位置） 使用 key 赋予每个组件一个明确的身份 方法一比较简单，将组件渲染放置与独立的作用域内就可以实现。主要看方法二，这是最通用的方法。在 渲染列表 时，通常会指定一个合适的 key ，但 key 不只可以用于列表！还可以使用 key 来让 React 区分任何组件。默认情况下，React 使用父组件内部的顺序（“第一个计数器”、“第二个计数器”）来区分组件。但是 key 可以告诉 React 这不仅仅是 第一个 或者 第二个 计数器，还是一个特定的计数器。这样，在不同组件之间切换便不会使 state 被保留下来，例如如下示例： 为不同组件指定对应的key123456789101112131415161718192021222324252627282930313233343536373839404142import { useState } from 'react';export default function Scoreboard() { const [isPlayerA, setIsPlayerA] = useState(true); return ( &lt;div&gt; {isPlayerA ? ( &lt;Counter key=&quot;Taylor&quot; person=&quot;Taylor&quot; /&gt; ) : ( &lt;Counter key=&quot;Sarah&quot; person=&quot;Sarah&quot; /&gt; )} &lt;button onClick={() =&gt; { setIsPlayerA(!isPlayerA); }}&gt; 下一位玩家！ &lt;/button&gt; &lt;/div&gt; );}function Counter({ person }) { const [score, setScore] = useState(0); const [hover, setHover] = useState(false); let className = 'counter'; if (hover) { className += ' hover'; } return ( &lt;div className={className} onPointerEnter={() =&gt; setHover(true)} onPointerLeave={() =&gt; setHover(false)} &gt; &lt;h1&gt;{person} 的分数：{score}&lt;/h1&gt; &lt;button onClick={() =&gt; setScore(score + 1)}&gt; 加一 &lt;/button&gt; &lt;/div&gt; );} 指定一个 key 能够让 React 将 key 本身而非它们在父组件中的顺序作为位置的一部分。这就是为什么尽管用 JSX 将组件渲染在相同位置，但在 React 看来它们是两个不同的计数器。因此它们永远都不会共享 state。每当一个计数器出现在屏幕上时，它的 state 会被创建出来。每当它被移除时，它的 state 就会被销毁。在它们之间切换会一次又一次地使它们的 state 重置。需要强调的是：key 不是全局唯一的，它们只能指定其在父组件内部的顺序，为 React 确定同一位置组件提供辅助信息。 总结组件间共享状态可以通过“状态提升”将需要共享的状态放至最近的公共父组件中，再通过 props 传递给子组件；如果要改变状态，还可以将父组件的状态处理函数一同传递给子组件。此外，同一类型组件若在 UI 树中的相同位置被多次渲染，其状态会得到相应的保留，如果两个条件不满足任何一个，都会使得状态被刷新。","link":"/2024/03/framworks/front_framworks/react/share-states-in-components/"},{"title":"React UI 中的声明式思维","text":"声明式的考虑UI声明式UI意味着不必直接启用、关闭、显示或隐藏组件，而是只需要 声明你想要显示的内容， React 就会通过计算得出该如何去更新 UI。在 React 中，可以通过如下步骤思考如何实现UI效果： 定位组件中不同的视图状态 确定是什么触发了这些 state 的改变 表示内存中的 state（需要使用 useState） 删除任何不必要的 state 变量 连接事件处理函数去设置 state 定位组件中不同的视图状态可视化 UI 界面中用户可能看到的所有不同的“状态”，例如： 无数据：表单有一个不可用状态的“提交”按钮。 输入中：表单有一个可用状态的“提交”按钮。 提交中：表单完全处于不可用状态，加载动画出现。 成功时：显示“成功”的消息而非表单。 错误时：与输入状态类似，但会多错误的消息。 在添加逻辑之前去“模拟”不同的状态或创建“模拟状态”，这个过程可在书写逻辑前快速迭代 UI。官网示例代码如下： 表单布局12345678910111213141516171819202122export default function Form({ status = 'empty'}) { if (status === 'success') { return &lt;h1&gt;That's right!&lt;/h1&gt; } return ( &lt;&gt; &lt;h2&gt;City quiz&lt;/h2&gt; &lt;p&gt; In which city is there a billboard that turns air into drinkable water? &lt;/p&gt; &lt;form&gt; &lt;textarea /&gt; &lt;br /&gt; &lt;button&gt; Submit &lt;/button&gt; &lt;/form&gt; &lt;/&gt; )} 确定是什么触发了这些状态的改变触发 state 的更新来响应两种输入： 人为输入。比如点击按钮、在表单中输入内容，或导航到链接。 计算机输入。比如网络请求得到反馈、定时器被触发，或加载一张图片。 以上两种情况中，必须设置 state 变量 去更新 UI。对于正在开发中的表单来说，需要改变 state 以响应几个不同的输入： 改变输入框中的文本时（人为）应该根据输入框的内容是否是空值，从而决定将表单的状态从空值状态切换到输入中或切换回原状态。 点击提交按钮时（人为）应该将表单的状态切换到提交中的状态。 网络请求成功后（计算机）应该将表单的状态切换到成功的状态。 网络请求失败后（计算机）应该将表单的状态切换到失败的状态，与此同时，显示错误信息。 可通过如下表示方法，对状态变化进行可视化： 通过 useState 表示内存中的 state接下来需要在内存中通过 useState表示组件中的视图状态。诀窍很简单：state 的每个部分都是“处于变化中的”，并且让“变化的部分”尽可能的少。根据上一部分的状态图，需要存储输入的 answer 以及用于存储最后一个错误的 error，这是必须的两个状态。除此之外，一开始可以添加足够多的 state 开始，确保所有可能的视图状态都囊括其中： 表单状态12345678910// 必须状态const [answer, setAnswer] = useState(''); const [error, setError] = useState(null);// 其余状态const [isEmpty, setIsEmpty] = useState(true); const [isTyping, setIsTyping] = useState(false); const [isSubmitting, setIsSubmitting] = useState(false); const [isSuccess, setIsSuccess] = useState(false); const [isError, setIsError] = useState(false); 删除任何不必要的 state 变量为避免 state 内容中的重复，从而只需要关注那些必要的部分，可以对前一步中的状态进行重构。这可以让组件更容易被理解，减少重复并且避免歧义，同时防止出现在内存中的 state 不代表任何你希望用户看到的有效 UI 的情况。可以通过如下一些问题促进对状态的思考： 这个 state 是否会导致矛盾？例如，isTyping 与 isSubmitting 的状态不能同时为 true。矛盾的产生通常说明了这个 state 没有足够的约束条件。两个布尔值有四种可能的组合，但是只有三种对应有效的状态。为了将“不可能”的状态移除，可以将 'typing'、'submitting' 以及 'success' 这三个中的其中一个与 status 结合。 相同的信息是否已经在另一个 state 变量中存在？另一个矛盾：isEmpty 和 isTyping 不能同时为 true。通过使它们成为独立的 state 变量，可能会导致它们不同步并导致 bug。幸运的是，可以移除 isEmpty 转而用 message.length === 0。 是否可以通过另一个 state 变量的相反值得到相同的信息？isError 是多余的，因为可以检查 error !== null。 重构完成以后，剩下三个必要的状态： 精简后的表单状态123const [answer, setAnswer] = useState(''); const [error, setError] = useState(null); const [status, setStatus] = useState('typing'); // 'typing', 'submitting', or 'success' 连接事件处理函数以设置 state最后，创建事件处理函数以设置 state 变量。下面是绑定好事件的最终表单： 绑定事件处理函数后的表单示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import { useState } from 'react';export default function Form() { const [answer, setAnswer] = useState(''); const [error, setError] = useState(null); const [status, setStatus] = useState('typing'); if (status === 'success') { return &lt;h1&gt;That's right!&lt;/h1&gt; } async function handleSubmit(e) { e.preventDefault(); setStatus('submitting'); try { await submitForm(answer); setStatus('success'); } catch (err) { setStatus('typing'); setError(err); } } function handleTextareaChange(e) { setAnswer(e.target.value); } return ( &lt;&gt; &lt;h2&gt;City quiz&lt;/h2&gt; &lt;p&gt; In which city is there a billboard that turns air into drinkable water? &lt;/p&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;textarea value={answer} onChange={handleTextareaChange} disabled={status === 'submitting'} /&gt; &lt;br /&gt; &lt;button disabled={ answer.length === 0 || status === 'submitting' }&gt; Submit &lt;/button&gt; {error !== null &amp;&amp; &lt;p className=&quot;Error&quot;&gt; {error.message} &lt;/p&gt; } &lt;/form&gt; &lt;/&gt; );}function submitForm(answer) { // Pretend it's hitting the network. return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { let shouldError = answer.toLowerCase() !== 'lima' if (shouldError) { reject(new Error('Good guess but a wrong answer. Try again!')); } else { resolve(); } }, 1500); });} 总结总的来说，在 React 中，可从 UI 整体出发，为每个视图状态先声明 UI。在组件开发过程中，列出所有状态及其转换关系，通过 useState 将状态放置于组件内，在移除冗余状态后，利用设值函数及事件处理函数，根据事件结果调整状态变化。","link":"/2024/03/framworks/front_framworks/react/thinking-in-declarative-ui/"}],"tags":[{"name":"容器化","slug":"容器化","link":"/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"开发工具","slug":"开发工具","link":"/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"效率","slug":"效率","link":"/tags/%E6%95%88%E7%8E%87/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"前端框架","slug":"前端框架","link":"/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"categories":[{"name":"容器化","slug":"容器化","link":"/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"性能优化","slug":"性能优化","link":"/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Docker","slug":"容器化/Docker","link":"/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/Docker/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Sql","slug":"性能优化/Sql","link":"/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Sql/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Gradle","slug":"工具/Gradle","link":"/categories/%E5%B7%A5%E5%85%B7/Gradle/"},{"name":"Maven","slug":"工具/Maven","link":"/categories/%E5%B7%A5%E5%85%B7/Maven/"},{"name":"nodejs","slug":"工具/nodejs","link":"/categories/%E5%B7%A5%E5%85%B7/nodejs/"},{"name":"Kotlin","slug":"编程语言/Kotlin","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Kotlin/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"前端框架","slug":"框架/前端框架","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"React","slug":"框架/前端框架/React","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/"}],"pages":[]}