{"posts":[{"title":"Docker 镜像操作","text":"什么是镜像镜像操作命令docker image search","link":"/2024/03/container/docker-images-oprator/"},{"title":"Docker 容器操作","text":"","link":"/2024/03/container/docker-container-oprator/"},{"title":"React 事件响应及单组件状态处理","text":"事件响应事件处理函数 使用 React 可以在 JSX 中添加 事件处理函数。其中事件处理函数为自定义函数，它将在响应交互（如点击、悬停、表单输入框获得焦点等）时触发。 React 官方文档 – 响应事件 大多元素均可绑定响应的事件，以按钮为例，最常使用的事件为点击事件。在 Ract 中为一个按钮添加点击事件非常简单，只需要在组件内创建一个事件处理函数，并在标签返回时，将其绑定到 onClick 属性上即可： 为按钮绑定点击事件12345678910111213function App() { function handleButtonClick() { alert(&quot;Button clicked.&quot;); } return ( &lt;button onClick={handleButtonClick}&gt; Click me &lt;/button&gt; );}export default App; 事件处理函数通常有如下特点： 通常在 组件内部 定义。（这样做的好处是可以直接访问组件内部的 props 。） 名称以 handle 开头，后跟事件名称。（这只是一种惯例，并非强制。） 一种更为简洁的方式为使用 Javascript 的箭头函数，为一个元素内联绑定事件处理函数，这种方式当处理函数比较小的情况下是非常方便的： 内联函数绑定事件处理1234567891011function App() { return ( &lt;button onClick={()=&gt;{ alert(&quot;Button clicked.&quot;); }}&gt; Click me &lt;/button&gt; );}export default App; 通过 props 传递事件处理函数通常，会在父组件中定义子组件的事件处理函数，这样做提高了子组件的可重用性。例如官网如下示例，根据需要，将不通的事件处理函数传递给按钮组件后，可以实现文件上传、电影点播等不同功能，但是子组件 Button 内部编码却不需要做任何改变。 传递事件处理函数给子组件12345678910111213141516171819202122232425262728293031323334353637 // 定义公共组件，其点击事件在使用时传入function Button({ onClick, children }) { return ( &lt;button onClick={onClick}&gt; {children} // 子组件接收标签内容 &lt;/button&gt; );}function PlayButton({ movieName }) { function handlePlayClick() { alert(`正在播放 ${movieName}！`); } return ( &lt;Button onClick={handlePlayClick}&gt; 播放 &quot;{movieName}&quot; &lt;/Button&gt; );}function UploadButton() { return ( &lt;Button onClick={() =&gt; alert('正在上传！')}&gt; 上传图片 &lt;/Button&gt; );}export default function Toolbar() { return ( &lt;div&gt; &lt;PlayButton movieName=&quot;迪迦奥特曼&quot; /&gt; &lt;UploadButton /&gt; &lt;/div&gt; );} 事件传播行为事件处理函数还会捕获任何来自子组件的事件，即事件从发生的地方开始，沿着 UI 树向上传播。例如： 子组件事件传播行为1234567891011export default function Toolbar() { return ( &lt;div className=&quot;Toolbar&quot; onClick={() =&gt; { alert('你点击了 toolbar ！'); }}&gt; &lt;button onClick={() =&gt; alert('正在播放！')}&gt; 播放电影 &lt;/button&gt; &lt;/div&gt; );} 上述实例中，div 及其子组件 button 均添加了点击事件，虽然行为不同，但是当点击按钮出发其事件处理后，对应的点击事件会沿着UI树向上传播至 div 中，进而触发 div 的点击事件回调其处理函数。所以会看到两次弹窗。但是，这种传播是可以被中断的。每个事件处理函数接收一个 事件对象 作为唯一的参数，可以使用此对象来读取有关事件的信息。同样的，若想阻止事件向上传播，可以在子组件事件处理函数的开始处，借助事件的 e.stopPropagation() 方法实现。（浏览器内置组件可以通过自定义组件来包装一下。） 阻止子组件事件传播行为12345678910function Button({ onClick, children }) { return ( &lt;button onClick={e =&gt; { e.stopPropagation(); // 阻止事件传播至父组件 onClick(); }}&gt; {children} &lt;/button&gt; );} 阻止组件默认行为某些浏览器事件具有与事件相关联的默认行为。例如，点击 &lt;form&gt; 表单内部的按钮会触发表单提交事件，默认情况下将重新加载整个页面，但是这种行为也是可以事件对象的 e.preventDefault() 方法来阻止的： 阻止组件的默认行为1234567891011export default function Signup() { return ( &lt;form onSubmit={e =&gt; { e.preventDefault(); // 阻止组件的默认行为 alert('提交表单！'); }}&gt; &lt;input /&gt; &lt;button&gt;发送&lt;/button&gt; &lt;/form&gt; );} State事件处理函数是执行副作用的最佳位置。同渲染函数不同，事件处理函数不需要是 纯函数，因此它是用来更改某些值的绝佳位置。例如，更改输入框的值以响应键入，或者更改列表以响应按钮的触发。但是，在修改数据前，通常需要记住修改的值，这在 React 中便是通过 State （状态）来实现的。通常情况下，在组件内部使用普通变量保存状态数据后，在事件（例如按钮的点击事件）处理过程中改变其数据后，无法实现新内容的渲染，这是因为： 局部变量无法在多次渲染中持久保存。 当 React 再次渲染组件时，会从头开始渲染，不会考虑之前对局部变量的任何更改。 更改局部变量不会触发渲染。 React 没有意识到它需要使用新数据再次渲染组件。 在 React 中，以上功能可以通过 Hook 函数 useState 实现，该函数接收1个参数，为状态的初始值；返回值可以解构为两个值：其中第一个取值为 状态 ，第二个值为 setter 函数，用于改变状态的取值，进而触发 React 重新渲染组件。 当编写一个存有 state 的组件时，需要考虑使用多少个 state 变量以及它们都是怎样的数据格式。尽管选择次优的 state 结构下也可以编写正确的程序，但有几个原则可以帮助做出更好的决策： 合并关联的 state。如果总是同时更新两个或更多的 state 变量，可以考虑将它们合并为一个单独的 state 变量。 避免互相矛盾的 state。当 state 结构中存在多个相互矛盾或“不一致”的 state 时，就可能为此会留下隐患。应尽量避免这种情况。 避免冗余的 state。如果能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入该组件的 state 中。 避免重复的 state。当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，这会很难保持它们同步。应尽可能减少重复。 避免深度嵌套的 state。深度分层的 state 更新起来不是很方便。如果可能的话，最好以扁平化方式构建 state。 添加一个 state 变量要添加 state 变量，先从文件顶部的 React 中导入 useState： 导入 useState Hook1import { useState } from 'react'; 然后接收 Hook 返回的两个值，这两个取值是相互对应的： 解构 useState 的返回值1const [state, setXxx] = useState(inieState); 官网提供的完整实例如下： 官方示例1234567891011121314151617181920212223242526272829303132333435import { useState } from 'react';import { sculptureList } from './data.js';export default function Gallery() { const [index, setIndex] = useState(0); function handleClick() { // React 会记住中间值 // 即使再次渲染时看到的仍是初始值，但是会使用中间值进行相应的渲染 setIndex(index + 1); } let sculpture = sculptureList[index]; return ( &lt;&gt; &lt;button onClick={handleClick}&gt; Next &lt;/button&gt; &lt;h2&gt; &lt;i&gt;{sculpture.name} &lt;/i&gt; by {sculpture.artist} &lt;/h2&gt; &lt;h3&gt; ({index + 1} of {sculptureList.length}) &lt;/h3&gt; &lt;img src={sculpture.url} alt={sculpture.alt} /&gt; &lt;p&gt; {sculpture.description} &lt;/p&gt; &lt;/&gt; );} Hooks ——以 use 开头的函数——只能在组件或自定义 Hook 的最顶层调用。 你不能在条件语句、循环语句或其他嵌套函数内调用 Hook。Hook 是函数，但将它们视为关于组件需求的无条件声明会很有帮助。在组件顶部 “use” React 特性，类似于在文件顶部“导入”模块。 React 文档 – state 组件的记忆 每个组件可以同时定义多个不同的 state ，不会相互影响。但如果发现经常同时更改多个 state 变量，那么可以由一个值为对象的 state 变量的多个字段对应一个 state 变量，在事件处理过程中，通过更改对象的相应字段即可。 State 是隔离且私有的 State 是屏幕上组件实例内部的状态。换句话说，如果你渲染同一个组件两次，每个副本都会有完全隔离的 state！改变其中一个不会影响另一个。 React 文档 – state 组件的记忆 渲染和提交在 React 中，UI 的更新通常有三个步骤： 触发一次渲染 初次渲染。应用启动时，会触发初次渲染。这个过程通过调用目标 DOM 节点的 createRoot，然后再调用组件调用 render 函数完成。 状态更新时重新渲染。一旦组件被初次渲染，就可以通过使用 setter 函数更新其状态来触发之后的渲染。更新组件的状态会自动将一次渲染送入队列。 set 函数 仅更新 下一次 要渲染的状态变量。如果在调用 setter 函数后读取状态变量，则还是会看到之前的旧值；如果提供的新值与当前 state 相同，则不会触发对应组件及子组件的渲染。 React 渲染组件 在进行初次渲染时, React 会调用根组件。 对于后续的渲染, React 会调用内部状态更新触发了渲染的函数组件。 这个过程是递归的：如果更新后的组件会返回某个另外的组件，那么 React 接下来就会渲染返回的组件，而如果返回的组件又返回了某个组件，那么 React 接下来就会渲染继续渲染后续返回的组件，以此类推。这个过程会持续下去，直到没有更多的嵌套组件并且 React 确切知道哪些东西应该显示到屏幕上为止。 React 把更改提交到 DOM 上 对于初次渲染， React 会使用 appendChild() DOM API 将其创建的所有 DOM 节点放在屏幕上。 对于重渲染， React 将应用最少的必要操作（在渲染时计算。），以使得 DOM 与最新的渲染输出相互匹配。 state 的进一步理解state 如同一张快照 是官方对 state 的一个描述。据此，每次状态变化触发渲染时，渲染的结果都是根据上一次渲染后的结果计算得到。因此，即使在事件处理时多次根据状态的值计算的下一次渲染状态，得到的结果都是相同的。例如： 根据快照 number 计算下一次渲染的结果1234567891011121314151617import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 1); setNumber(number + 1); setNumber(number + 1); }}&gt;+3&lt;/button&gt; &lt;/&gt; )} 上述官方示例中，虽然在按钮的事件处理函数中对 number 状态连续做了三次加一，但是因为都是基于上一次渲染结果的快照（即组件加载时的 0）计算更新，所以最终在下一次渲染时，number 的值为 1，而非 3。另一方面，根据官方文档： 一个 state 变量的值永远不会在一次渲染的内部发生变化， 即使其事件处理函数的代码是异步的。 React 文档 – state 如同一张快照 在一个新的场景下，如果先对状态进行更新，触发组件重新渲染以后，在直接使用对应的状态（例如弹窗显示等），实际上使用的值是上一次渲染的快照值。 渲染组建后随机使用状态做弹窗123456789101112131415import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 5); alert(number); }}&gt;+5&lt;/button&gt; &lt;/&gt; )} 多次更新状态值 React 会等到事件处理函数中的 所有 代码都运行完毕再处理你的 state 更新。 React 文档 – 把一系列 state 更新加入队列 实际上，事件处理函数及其中任何代码执行完成 之后，UI 才会更新，也就是所谓的批处理，这可以保证渲染结果的正确性。在上一节中的示例中，更新状态值都是基于快照的值进行的，而传递给更新函数的都是计算后的值。有时候需要连续多次的对状态的值进行更新，例如，这种场景下，可以传入一个函数给到设值函数，这样一个更新函数接收相应的参数，用于累积结果： 根据更新队列中的值 n，计算后续更新的值12345678910111213141516import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 5); setNumber(n =&gt; n + 1); }}&gt;增加数字&lt;/button&gt; &lt;/&gt; )} 更新 state 中的对象及数组在 React 中，如果状态对应的是一个对象或者数组，如果单纯相应对象的某个属性发生变化，是不会通知到 React 进行重新渲染的。只有通过设值函数利用修改后的 新对象 或者 新数组 更新状态，让 React 感知到相应变化，才能触发组件的重新渲染。总体上，把握一个原则， 不要妄想直接改变原有对象触发渲染，不管什么时候，要想React重新渲染组件，就通过复制或者能够返回一个新对象/数组的函数，传递一个全新的状态至对应状态的设置函数 。例如： 传递一个新的对象，触发渲染并更新红点位置1234567891011121314151617181920212223242526272829303132import { useState } from 'react';export default function MovingDot() { const [position, setPosition] = useState({ x: 0, y: 0 }); return ( &lt;div onPointerMove={e =&gt; { setPosition({ // 传入一个新的对象 x: e.clientX, y: e.clientY }); }} style={{ position: 'relative', width: '100vw', height: '100vh', }}&gt; &lt;div style={{ position: 'absolute', backgroundColor: 'red', borderRadius: '50%', transform: `translate(${position.x}px, ${position.y}px)`, left: -10, top: -10, width: 20, height: 20, }} /&gt; &lt;/div&gt; );} 如果对象比较复杂，可以使用 展开语法 进行对象复制： 展开语法复制对象/数组1234567891011// 复制对象setPerson({ ...person, // 复制上一个 person 中的所有字段 firstName: e.target.value // 但是覆盖 firstName 字段 });// 复制数组setArtists([{ id: nextId++, name: name }, ...artists // 将原数组中的元素放在末尾 ]); 如果对象比较复杂，数据一些逻辑较为啰嗦，可以利用 Immer 库简化相应的更新操作。添加相应的依赖： immer 依赖12345678910111213141516{ &quot;dependencies&quot;: { &quot;immer&quot;: &quot;1.7.3&quot;, &quot;react&quot;: &quot;latest&quot;, &quot;react-dom&quot;: &quot;latest&quot;, &quot;react-scripts&quot;: &quot;latest&quot;, &quot;use-immer&quot;: &quot;0.5.1&quot; }, &quot;scripts&quot;: { &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; }, &quot;devDependencies&quot;: {}} Immer 使用举例： Immer 用法123456789101112131415161718192021222324252627282930313233343536373839import { useState } from 'react';import { useImmer } from 'use-immer';const initialList = [ { id: 0, title: 'Big Bellies', seen: false }, { id: 1, title: 'Lunar Landscape', seen: false }, { id: 2, title: 'Terracotta Army', seen: true },];...export default function BucketList() { const [myList, updateMyList] = useImmer( initialList ); function handleToggleMyList(id, nextSeen) { updateMyList(draft =&gt; { const artwork = draft.find(a =&gt; a.id === id ); artwork.seen = nextSeen; }); } return ( &lt;&gt; &lt;h1&gt;艺术愿望清单&lt;/h1&gt; &lt;h2&gt;我想看的艺术清单：&lt;/h2&gt; &lt;ItemList artworks={myList} onToggle={handleToggleMyList} /&gt; &lt;h2&gt;你想看的艺术清单：&lt;/h2&gt; &lt;ItemList artworks={yourList} onToggle={handleToggleYourList} /&gt; &lt;/&gt; );}...","link":"/2024/03/framworks/front_framworks/react/event-response-and-single-comp-state/"},{"title":"Docker 安装及配置","text":"1 安装1.1 debain 使用脚本自动安装 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 手动安装 更新软件包索引，并且安装必要的依赖软件，来添加一个新的 HTTPS 软件源 12sudo apt updatesudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common 使用下面的 curl 导入源仓库的 GPG key： 12345# 官方：curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# Aliyuncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 安装 Docker 最新版本 12sudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 启动Docker 12sudo systemctl enable dockersudo systemctl start docker 建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 123456# 建立 docker 组：sudo groupadd docker# 将当前用户加入 docker 组：sudo usermod -aG docker $USER# 退出当前终端并重新登录 docker 镜像 1234567891011121314151617181920网易：http://hub-mirror.c.163.com中科大镜像地址：http://mirrors.ustc.edu.cn/中科大github地址：https://github.com/ustclug/mirrorrequestAzure中国镜像地址：http://mirror.azure.cn/Azure中国github地址：https://github.com/Azure/container-service-for-azure-chinaDockerHub镜像仓库: https://hub.docker.com/ 阿里云镜像仓库： https://cr.console.aliyun.com google镜像仓库： https://console.cloud.google.com/gcr/images/google-containers/GLOBAL （如果你本地可以翻墙的话是可以连上去的 ）coreos镜像仓库： https://quay.io/repository/ RedHat镜像仓库： https://access.redhat.com/containers配置：sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot;: [&quot;https://cr.console.aliyun.com&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker 1.2 Centos 使用脚本自动安装 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 手动安装 安装依赖 1sudo yum install -y yum-utils # openEuler 自带 dnf 管理器，可直接管理 yum 源 配置docker仓库 12345官方：sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoAliyun:sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 下载安装 12sudo yum makecache fast # 更新索引sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin （openEuler）更新索引时，可能会报错404，可按如下方法解决 1234567cd /etc/yum.repos.d/# ls -lhrt # -rw-r--r--. 1 root root 2.7K Dec 9 20:33 openEuler.repo.bak# -rw-r--r--. 1 root root 3.0K Dec 9 20:37 openEuler.repo# -rw-r--r--. 1 root root 2.0K Feb 3 16:45 docker-ce.repo编辑 docker-ce.repo，将 $releasever 替换为 8，即CentOS8，使得能够在阿里云的centos仓库中找到对应的工具","link":"/2024/02/container/docker-install/"},{"title":"React 利用Reducer管理复杂状态及Context深层传递状态","text":"迁移状态逻辑至 Reducer 中随着组件复杂度的增加，将很难一眼看清所有的组件状态更新逻辑。例如，下面的 TaskApp 组件有一个数组类型的状态 tasks，并通过三个不同的事件处理程序来实现任务的添加、删除和修改： 多事件处理程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import { useState } from 'react';import AddTask from './AddTask.js';import TaskList from './TaskList.js';export default function TaskApp() { const [tasks, setTasks] = useState(initialTasks); function handleAddTask(text) { setTasks([ ...tasks, { id: nextId++, text: text, done: false, }, ]); } function handleChangeTask(task) { setTasks( tasks.map((t) =&gt; { if (t.id === task.id) { return task; } else { return t; } }) ); } function handleDeleteTask(taskId) { setTasks(tasks.filter((t) =&gt; t.id !== taskId)); } return ( &lt;&gt; &lt;h1&gt;布拉格的行程安排&lt;/h1&gt; &lt;AddTask onAddTask={handleAddTask} /&gt; &lt;TaskList tasks={tasks} onChangeTask={handleChangeTask} onDeleteTask={handleDeleteTask} /&gt; &lt;/&gt; );}let nextId = 3;const initialTasks = [ {id: 0, text: '参观卡夫卡博物馆', done: true}, {id: 1, text: '看木偶戏', done: false}, {id: 2, text: '打卡列侬墙', done: false},]; 这个组件的每个事件处理程序都通过 setTasks 来更新状态。随着这个组件的不断迭代，其状态逻辑也会越来越多。为了降低这种复杂度，并让所有逻辑都可以存放在一个易于理解的地方，可以通过三个步骤将逻辑移到组件之外的一个称为 reducer 的函数中（useReducer）： 将设置状态的逻辑 修改 成 dispatch 的一个 action 编写 一个 reducer 函数 在组件中 使用 reducer 将设置状态的逻辑修改成 dispatch 的一个 action","link":"/2024/03/framworks/front_framworks/react/reducer-state-mgr-and-context/"},{"title":"Docker 仓库配置及使用","text":"","link":"/2024/03/container/docker-repo-oprator/"},{"title":"React 在组件间共享状态","text":"状态共享的一个例子要实现两个组件的状态始终同步更改，可以将相关 state 从这两个组件上移除，并把 state 放到它们的公共父级，再通过 props 将 state 传递给这两个组件。这个操作被称为“状态提升”。共享状态的场景在前端开发中非常常见，这里整理官网提供的状态提升示例，进一步巩固状态提升的掌握。示例如下： 状态提升前1234567891011121314151617181920212223242526272829303132import { useState } from 'react';function Panel({ title, children }) { const [isActive, setIsActive] = useState(false); return ( &lt;section className=&quot;panel&quot;&gt; &lt;h3&gt;{title}&lt;/h3&gt; {isActive ? ( &lt;p&gt;{children}&lt;/p&gt; ) : ( &lt;button onClick={() =&gt; setIsActive(true)}&gt; 显示 &lt;/button&gt; )} &lt;/section&gt; );}export default function Accordion() { return ( &lt;&gt; &lt;h2&gt;哈萨克斯坦，阿拉木图&lt;/h2&gt; &lt;Panel title=&quot;关于&quot;&gt; 阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。 &lt;/Panel&gt; &lt;Panel title=&quot;词源&quot;&gt; 这个名字来自于 &lt;span lang=&quot;kk-KZ&quot;&gt;алма&lt;/span&gt;，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，&lt;i lang=&quot;la&quot;&gt;Malus sieversii&lt;/i&gt; 被认为是现今苹果的祖先。 &lt;/Panel&gt; &lt;/&gt; );} 上述示例中，父组件 Accordion 渲染了 2 个独立的 Panel 组件，每个 Panel 组件都有一个布尔值 isActive，用于独立的控制组件自己的内容是否可见。假设想改变这种行为，以便在任何时候只展开一个面板。这个时候，isActive 就不能放置于组件自身，需要将其提升至父组件中，以便可以将 isActive 状态共享给两个子组件。这可以通过如下三步实现： 从子组件中 移除 state 。 从父组件 传递 硬编码数据。 为共同的父组件添加 state ，并将其与事件处理函数一起向下传递。 从子组件中移除状态首先，将 Panel 组件对 isActive 的控制权交给他们的父组件，由父组件将 isActive 作为 prop 传给子组件 Panel。因此，先从 Panel 组件中删除 isActive 状态，并把 isActive 加入 Panel 组件的 props 中： 移除子组件 isActive 状态12345// 从子组件中删除这一行const [isActive, setIsActive] = useState(false);// 子组件的 props 中加入 isActivefunction Panel({ title, children, isActive }){ ... } 从公共父组件传递硬编码数据然后，为了实现状态提升，须定位到想协调的两个子组件最近的公共父组件： Accordion (最近的公共父组件) Panel Panel 在这个示例中，最近的公共父组件是 Accordion。因为它位于两个面板之上，可以控制两个子组件的 props，所以它将成为当前激活面板的“控制之源”。这里通过 Accordion 组件将 isActive 硬编码值（例如 true ）传递给两个面板，可以看到不同取值下两个子组件的行为： 传递 isActive 的硬编码状态给两个子组件123456789101112131415161718192021222324252627282930import { useState } from 'react';export default function Accordion() { return ( &lt;&gt; &lt;h2&gt;哈萨克斯坦，阿拉木图&lt;/h2&gt; &lt;Panel title=&quot;关于&quot; isActive={true}&gt; 阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。 &lt;/Panel&gt; &lt;Panel title=&quot;词源&quot; isActive={true}&gt; 这个名字来自于 &lt;span lang=&quot;kk-KZ&quot;&gt;алма&lt;/span&gt;，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，&lt;i lang=&quot;la&quot;&gt;Malus sieversii&lt;/i&gt; 被认为是现今苹果的祖先。 &lt;/Panel&gt; &lt;/&gt; );}function Panel({ title, children, isActive }) { return ( &lt;section className=&quot;panel&quot;&gt; &lt;h3&gt;{title}&lt;/h3&gt; {isActive ? ( &lt;p&gt;{children}&lt;/p&gt; ) : ( &lt;button onClick={() =&gt; setIsActive(true)}&gt; 显示 &lt;/button&gt; )} &lt;/section&gt; );} 为公共父组件添加状态状态提升通常会改变原状态的数据存储类型，以便子组件更加精确的识别想要的行为，但是改变并不是必须的，本示例就是如此。但在官网的示例中，改用数字作为当前被激活 Panel 的索引，而不是 boolean 值，即当 activeIndex 为 0 时，激活第一个面板，为 1 时，激活第二个面板。另一方面，在任意一个 Panel 中点击“显示”按钮都需要更改 Accordion 中的激活索引值。但在 Panel 中无法直接设置状态 activeIndex 的值，因为该状态是在 Accordion 组件内部定义的。不过Accordion 组件需要可以 显式允许 Panel 组件通过 将事件处理程序作为 prop 向下传递 来更改其状态父组件中的状态： 父组件传递共享 isActive 状态及设值函数123456789101112131415161718192021222324252627282930313233343536373839404142434445import { useState } from 'react';export default function Accordion() { const [activeIndex, setActiveIndex] = useState(0); return ( &lt;&gt; &lt;h2&gt;哈萨克斯坦，阿拉木图&lt;/h2&gt; &lt;Panel title=&quot;关于&quot; isActive={activeIndex === 0} onShow={() =&gt; setActiveIndex(0)} &gt; 阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。 &lt;/Panel&gt; &lt;Panel title=&quot;词源&quot; isActive={activeIndex === 1} onShow={() =&gt; setActiveIndex(1)} &gt; 这个名字来自于 &lt;span lang=&quot;kk-KZ&quot;&gt;алма&lt;/span&gt;，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，&lt;i lang=&quot;la&quot;&gt;Malus sieversii&lt;/i&gt; 被认为是现今苹果的祖先。 &lt;/Panel&gt; &lt;/&gt; );}function Panel({ title, children, isActive, onShow}) { return ( &lt;section className=&quot;panel&quot;&gt; &lt;h3&gt;{title}&lt;/h3&gt; {isActive ? ( &lt;p&gt;{children}&lt;/p&gt; ) : ( &lt;button onClick={onShow}&gt; 显示 &lt;/button&gt; )} &lt;/section&gt; );} 每个状态都对应唯一的数据源需要注意的是：对于每个独特的状态，都应该存在且只存在于一个指定的组件中作为 state。这一原则也被称为拥有 “可信单一数据源”。它并不意味着所有状态都存在一个地方——对每个状态来说，都需要一个特定的组件来保存这些状态信息。应该 将状态提升 到公共父级，或 将状态传递 到需要它的子级中，而不是在组件之间复制共享的状态。此外，应用会随着操作而变化。当将状态上下移动时，依然会需要确定每个状态在哪里“活跃”。 state 的保留和重置状态与渲染树中的位置相关虽说各个组件的 state 是各自独立的，但是这些状态是保存在 React 中的，React 可以跟踪组件在渲染树中的位置将它保存的每个状态与正确的组件关联起来。开发过程中，可以控制在重新渲染过程中何时对 state 进行保留和重置。例如： 组件状态与位置12345678910111213141516171819202122232425262728293031323334import { useState } from 'react';export default function App() { const counter = &lt;Counter /&gt;; return ( &lt;div&gt; {counter} {counter} &lt;/div&gt; );}function Counter() { const [score, setScore] = useState(0); const [hover, setHover] = useState(false); let className = 'counter'; if (hover) { className += ' hover'; } return ( &lt;div className={className} onPointerEnter={() =&gt; setHover(true)} onPointerLeave={() =&gt; setHover(false)} &gt; &lt;h1&gt;{score}&lt;/h1&gt; &lt;button onClick={() =&gt; setScore(score + 1)}&gt; 加一 &lt;/button&gt; &lt;/div&gt; );} 在上述示例代码中，两个 counter 对象被先后两次渲染，尽管看上去是同一个对象，但是在 UI 树中，可以理解为原始对象的副本，而对应节点的状态则是由位置决定，React 根据位置关联对应的组件虚拟 Dom。前面文章提到过，状态是相互隔离的。因此，在此例子中，若点击各自组件的计数按钮，会发现两个组件计数器独自变化。下图为部分 UI 树： 此外，只有当在树中相同的位置渲染相同的组件时，React 才会一直保留着组件的 state。可以增加一个复选框，控制第二个计数器的是否渲染，将两个计数器的值递增，然后取消勾选 “渲染第二个计数器” 复选框，接着再次勾选它。可以发现，第二个组件的计数在重新勾选后，会从0开始。 增加复选框控制第二个组件渲染1234567891011121314151617181920export default function App() { const [showB, setShowB] = useState(true); return ( &lt;div&gt; &lt;Counter /&gt; {showB &amp;&amp; &lt;Counter /&gt;} &lt;label&gt; &lt;input type=&quot;checkbox&quot; checked={showB} onChange={e =&gt; { setShowB(e.target.checked) }} /&gt; 渲染第二个计数器 &lt;/label&gt; &lt;/div&gt; );}... 相同位置的相同组件会使得 state 被保留下来不过有一点乍一看可能与上述描述不一致，第一个组件如果被再次被渲染，只要该组件还被渲染在 UI 树的相同位置，React 就会保留它的 state。 这个相同位置指的是其在UI树中的位置，与在 jsx 代码中的位置无关。举个例子： 两个组件在同一位置被渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import { useState } from 'react';export default function App() { const [isFancy, setIsFancy] = useState(false); return ( &lt;div&gt; {isFancy ? ( &lt;Counter isFancy={true} /&gt; ) : ( &lt;Counter isFancy={false} /&gt; )} &lt;label&gt; &lt;input type=&quot;checkbox&quot; checked={isFancy} onChange={e =&gt; { setIsFancy(e.target.checked) }} /&gt; 使用好看的样式 &lt;/label&gt; &lt;/div&gt; );}function Counter({ isFancy }) { const [score, setScore] = useState(0); const [hover, setHover] = useState(false); let className = 'counter'; if (hover) { className += ' hover'; } if (isFancy) { className += ' fancy'; } return ( &lt;div className={className} onPointerEnter={() =&gt; setHover(true)} onPointerLeave={() =&gt; setHover(false)} &gt; &lt;h1&gt;{score}&lt;/h1&gt; &lt;button onClick={() =&gt; setScore(score + 1)}&gt; 加一 &lt;/button&gt; &lt;/div&gt; );} 当勾选或清空复选框的时候，计数器 state 并没有被重置。不管 isFancy 是 true 还是 false，根组件 App 返回的 div 的第一个子组件都是 &lt;Counter /&gt;，因为是位于相同位置的相同组件，所以对 React 来说，它是同一个计数器。这也就是说，在UI树中相同位置，渲染同类型组件，就会被视为同一个组件被渲染，同时相应的状态得以保留。与之不同的是，如果在相同位置渲染不同类型组件，则会使 state 重置，包括该组件的整个子树都会被重置 。一般来说，如果想在重新渲染时保留 state，几次渲染中的树形结构就应该相互“匹配”。结构不同会 React 在将一个组件从树中移除时销毁它的 state。因此，永远要将组件定义在最上层，并且在组件内部嵌套定义组件 。 在相同位置重置 state默认情况下，React 会在一个组件保持在同一位置时保留它的 state。但有时候，可能想要重置一个组件的 state。这里有两个方法可以实现重置 state： 将组件渲染在不同的位置（界面显示效果，实际在UI树中可能为左右不同位置） 使用 key 赋予每个组件一个明确的身份 方法一比较简单，将组件渲染放置与独立的作用域内就可以实现。主要看方法二，这是最通用的方法。在 渲染列表 时，通常会指定一个合适的 key ，但 key 不只可以用于列表！还可以使用 key 来让 React 区分任何组件。默认情况下，React 使用父组件内部的顺序（“第一个计数器”、“第二个计数器”）来区分组件。但是 key 可以告诉 React 这不仅仅是 第一个 或者 第二个 计数器，还是一个特定的计数器。这样，在不同组件之间切换便不会使 state 被保留下来，例如如下示例： 为不同组件指定对应的key123456789101112131415161718192021222324252627282930313233343536373839404142import { useState } from 'react';export default function Scoreboard() { const [isPlayerA, setIsPlayerA] = useState(true); return ( &lt;div&gt; {isPlayerA ? ( &lt;Counter key=&quot;Taylor&quot; person=&quot;Taylor&quot; /&gt; ) : ( &lt;Counter key=&quot;Sarah&quot; person=&quot;Sarah&quot; /&gt; )} &lt;button onClick={() =&gt; { setIsPlayerA(!isPlayerA); }}&gt; 下一位玩家！ &lt;/button&gt; &lt;/div&gt; );}function Counter({ person }) { const [score, setScore] = useState(0); const [hover, setHover] = useState(false); let className = 'counter'; if (hover) { className += ' hover'; } return ( &lt;div className={className} onPointerEnter={() =&gt; setHover(true)} onPointerLeave={() =&gt; setHover(false)} &gt; &lt;h1&gt;{person} 的分数：{score}&lt;/h1&gt; &lt;button onClick={() =&gt; setScore(score + 1)}&gt; 加一 &lt;/button&gt; &lt;/div&gt; );} 指定一个 key 能够让 React 将 key 本身而非它们在父组件中的顺序作为位置的一部分。这就是为什么尽管用 JSX 将组件渲染在相同位置，但在 React 看来它们是两个不同的计数器。因此它们永远都不会共享 state。每当一个计数器出现在屏幕上时，它的 state 会被创建出来。每当它被移除时，它的 state 就会被销毁。在它们之间切换会一次又一次地使它们的 state 重置。需要强调的是：key 不是全局唯一的，它们只能指定其在父组件内部的顺序，为 React 确定同一位置组件提供辅助信息。 总结组件间共享状态可以通过“状态提升”将需要共享的状态放至最近的公共父组件中，再通过 props 传递给子组件；如果要改变状态，还可以将父组件的状态处理函数一同传递给子组件。此外，同一类型组件若在 UI 树中的相同位置被多次渲染，其状态会得到相应的保留，如果两个条件不满足任何一个，都会使得状态被刷新。","link":"/2024/03/framworks/front_framworks/react/share-states-in-components/"},{"title":"React UI 中的声明式思维","text":"声明式的考虑UI声明式UI意味着不必直接启用、关闭、显示或隐藏组件，而是只需要 声明你想要显示的内容， React 就会通过计算得出该如何去更新 UI。在 React 中，可以通过如下步骤思考如何实现UI效果： 定位组件中不同的视图状态 确定是什么触发了这些 state 的改变 表示内存中的 state（需要使用 useState） 删除任何不必要的 state 变量 连接事件处理函数去设置 state 定位组件中不同的视图状态可视化 UI 界面中用户可能看到的所有不同的“状态”，例如： 无数据：表单有一个不可用状态的“提交”按钮。 输入中：表单有一个可用状态的“提交”按钮。 提交中：表单完全处于不可用状态，加载动画出现。 成功时：显示“成功”的消息而非表单。 错误时：与输入状态类似，但会多错误的消息。 在添加逻辑之前去“模拟”不同的状态或创建“模拟状态”，这个过程可在书写逻辑前快速迭代 UI。官网示例代码如下： 表单布局12345678910111213141516171819202122export default function Form({ status = 'empty'}) { if (status === 'success') { return &lt;h1&gt;That's right!&lt;/h1&gt; } return ( &lt;&gt; &lt;h2&gt;City quiz&lt;/h2&gt; &lt;p&gt; In which city is there a billboard that turns air into drinkable water? &lt;/p&gt; &lt;form&gt; &lt;textarea /&gt; &lt;br /&gt; &lt;button&gt; Submit &lt;/button&gt; &lt;/form&gt; &lt;/&gt; )} 确定是什么触发了这些状态的改变触发 state 的更新来响应两种输入： 人为输入。比如点击按钮、在表单中输入内容，或导航到链接。 计算机输入。比如网络请求得到反馈、定时器被触发，或加载一张图片。 以上两种情况中，必须设置 state 变量 去更新 UI。对于正在开发中的表单来说，需要改变 state 以响应几个不同的输入： 改变输入框中的文本时（人为）应该根据输入框的内容是否是空值，从而决定将表单的状态从空值状态切换到输入中或切换回原状态。 点击提交按钮时（人为）应该将表单的状态切换到提交中的状态。 网络请求成功后（计算机）应该将表单的状态切换到成功的状态。 网络请求失败后（计算机）应该将表单的状态切换到失败的状态，与此同时，显示错误信息。 可通过如下表示方法，对状态变化进行可视化： 通过 useState 表示内存中的 state接下来需要在内存中通过 useState表示组件中的视图状态。诀窍很简单：state 的每个部分都是“处于变化中的”，并且让“变化的部分”尽可能的少。根据上一部分的状态图，需要存储输入的 answer 以及用于存储最后一个错误的 error，这是必须的两个状态。除此之外，一开始可以添加足够多的 state 开始，确保所有可能的视图状态都囊括其中： 表单状态12345678910// 必须状态const [answer, setAnswer] = useState(''); const [error, setError] = useState(null);// 其余状态const [isEmpty, setIsEmpty] = useState(true); const [isTyping, setIsTyping] = useState(false); const [isSubmitting, setIsSubmitting] = useState(false); const [isSuccess, setIsSuccess] = useState(false); const [isError, setIsError] = useState(false); 删除任何不必要的 state 变量为避免 state 内容中的重复，从而只需要关注那些必要的部分，可以对前一步中的状态进行重构。这可以让组件更容易被理解，减少重复并且避免歧义，同时防止出现在内存中的 state 不代表任何你希望用户看到的有效 UI 的情况。可以通过如下一些问题促进对状态的思考： 这个 state 是否会导致矛盾？例如，isTyping 与 isSubmitting 的状态不能同时为 true。矛盾的产生通常说明了这个 state 没有足够的约束条件。两个布尔值有四种可能的组合，但是只有三种对应有效的状态。为了将“不可能”的状态移除，可以将 'typing'、'submitting' 以及 'success' 这三个中的其中一个与 status 结合。 相同的信息是否已经在另一个 state 变量中存在？另一个矛盾：isEmpty 和 isTyping 不能同时为 true。通过使它们成为独立的 state 变量，可能会导致它们不同步并导致 bug。幸运的是，可以移除 isEmpty 转而用 message.length === 0。 是否可以通过另一个 state 变量的相反值得到相同的信息？isError 是多余的，因为可以检查 error !== null。 重构完成以后，剩下三个必要的状态： 精简后的表单状态123const [answer, setAnswer] = useState(''); const [error, setError] = useState(null); const [status, setStatus] = useState('typing'); // 'typing', 'submitting', or 'success' 连接事件处理函数以设置 state最后，创建事件处理函数以设置 state 变量。下面是绑定好事件的最终表单： 绑定事件处理函数后的表单示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import { useState } from 'react';export default function Form() { const [answer, setAnswer] = useState(''); const [error, setError] = useState(null); const [status, setStatus] = useState('typing'); if (status === 'success') { return &lt;h1&gt;That's right!&lt;/h1&gt; } async function handleSubmit(e) { e.preventDefault(); setStatus('submitting'); try { await submitForm(answer); setStatus('success'); } catch (err) { setStatus('typing'); setError(err); } } function handleTextareaChange(e) { setAnswer(e.target.value); } return ( &lt;&gt; &lt;h2&gt;City quiz&lt;/h2&gt; &lt;p&gt; In which city is there a billboard that turns air into drinkable water? &lt;/p&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;textarea value={answer} onChange={handleTextareaChange} disabled={status === 'submitting'} /&gt; &lt;br /&gt; &lt;button disabled={ answer.length === 0 || status === 'submitting' }&gt; Submit &lt;/button&gt; {error !== null &amp;&amp; &lt;p className=&quot;Error&quot;&gt; {error.message} &lt;/p&gt; } &lt;/form&gt; &lt;/&gt; );}function submitForm(answer) { // Pretend it's hitting the network. return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { let shouldError = answer.toLowerCase() !== 'lima' if (shouldError) { reject(new Error('Good guess but a wrong answer. Try again!')); } else { resolve(); } }, 1500); });} 总结总的来说，在 React 中，可从 UI 整体出发，为每个视图状态先声明 UI。在组件开发过程中，列出所有状态及其转换关系，通过 useState 将状态放置于组件内，在移除冗余状态后，利用设值函数及事件处理函数，根据事件结果调整状态变化。","link":"/2024/03/framworks/front_framworks/react/thinking-in-declarative-ui/"}],"tags":[{"name":"容器化","slug":"容器化","link":"/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"前端框架","slug":"前端框架","link":"/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"categories":[{"name":"容器化","slug":"容器化","link":"/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"Docker","slug":"容器化/Docker","link":"/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/Docker/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"前端框架","slug":"框架/前端框架","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"React","slug":"框架/前端框架/React","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/"}],"pages":[]}