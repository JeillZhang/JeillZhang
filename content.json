{"posts":[{"title":"Docker 镜像操作","text":"什么是镜像镜像操作命令docker image search","link":"/2024/03/container/docker-images-oprator/"},{"title":"Docker 仓库配置及使用","text":"","link":"/2024/03/container/docker-repo-oprator/"},{"title":"Docker 容器操作","text":"","link":"/2024/03/container/docker-container-oprator/"},{"title":"Docker 安装及配置","text":"1 安装1.1 debain 使用脚本自动安装 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 手动安装 更新软件包索引，并且安装必要的依赖软件，来添加一个新的 HTTPS 软件源 12sudo apt updatesudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common 使用下面的 curl 导入源仓库的 GPG key： 12345# 官方：curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# Aliyuncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 安装 Docker 最新版本 12sudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 启动Docker 12sudo systemctl enable dockersudo systemctl start docker 建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 123456# 建立 docker 组：sudo groupadd docker# 将当前用户加入 docker 组：sudo usermod -aG docker $USER# 退出当前终端并重新登录 docker 镜像 1234567891011121314151617181920网易：http://hub-mirror.c.163.com中科大镜像地址：http://mirrors.ustc.edu.cn/中科大github地址：https://github.com/ustclug/mirrorrequestAzure中国镜像地址：http://mirror.azure.cn/Azure中国github地址：https://github.com/Azure/container-service-for-azure-chinaDockerHub镜像仓库: https://hub.docker.com/ 阿里云镜像仓库： https://cr.console.aliyun.com google镜像仓库： https://console.cloud.google.com/gcr/images/google-containers/GLOBAL （如果你本地可以翻墙的话是可以连上去的 ）coreos镜像仓库： https://quay.io/repository/ RedHat镜像仓库： https://access.redhat.com/containers配置：sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot;: [&quot;https://cr.console.aliyun.com&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker 1.2 Centos 使用脚本自动安装 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 手动安装 安装依赖 1sudo yum install -y yum-utils # openEuler 自带 dnf 管理器，可直接管理 yum 源 配置docker仓库 12345官方：sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoAliyun:sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 下载安装 12sudo yum makecache fast # 更新索引sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin （openEuler）更新索引时，可能会报错404，可按如下方法解决 1234567cd /etc/yum.repos.d/# ls -lhrt # -rw-r--r--. 1 root root 2.7K Dec 9 20:33 openEuler.repo.bak# -rw-r--r--. 1 root root 3.0K Dec 9 20:37 openEuler.repo# -rw-r--r--. 1 root root 2.0K Feb 3 16:45 docker-ce.repo编辑 docker-ce.repo，将 $releasever 替换为 8，即CentOS8，使得能够在阿里云的centos仓库中找到对应的工具","link":"/2024/02/container/docker-install/"},{"title":"React 事件响应及单组件状态处理","text":"事件响应事件处理函数 使用 React 可以在 JSX 中添加 事件处理函数。其中事件处理函数为自定义函数，它将在响应交互（如点击、悬停、表单输入框获得焦点等）时触发。 React 官方文档 – 响应事件 大多元素均可绑定响应的事件，以按钮为例，最常使用的事件为点击事件。在 Ract 中为一个按钮添加点击事件非常简单，只需要在组件内创建一个事件处理函数，并在标签返回时，将其绑定到 onClick 属性上即可： 为按钮绑定点击事件12345678910111213function App() { function handleButtonClick() { alert(&quot;Button clicked.&quot;); } return ( &lt;button onClick={handleButtonClick}&gt; Click me &lt;/button&gt; );}export default App; 事件处理函数通常有如下特点： 通常在 组件内部 定义。（这样做的好处是可以直接访问组件内部的 props 。） 名称以 handle 开头，后跟事件名称。（这只是一种惯例，并非强制。） 一种更为简洁的方式为使用 Javascript 的箭头函数，为一个元素内联绑定事件处理函数，这种方式当处理函数比较小的情况下是非常方便的： 内联函数绑定事件处理1234567891011function App() { return ( &lt;button onClick={()=&gt;{ alert(&quot;Button clicked.&quot;); }}&gt; Click me &lt;/button&gt; );}export default App; 通过 props 传递事件处理函数通常，会在父组件中定义子组件的事件处理函数，这样做提高了子组件的可重用性。例如官网如下示例，根据需要，将不通的事件处理函数传递给按钮组件后，可以实现文件上传、电影点播等不同功能，但是子组件 Button 内部编码却不需要做任何改变。 传递事件处理函数给子组件12345678910111213141516171819202122232425262728293031323334353637 // 定义公共组件，其点击事件在使用时传入function Button({ onClick, children }) { return ( &lt;button onClick={onClick}&gt; {children} // 子组件接收标签内容 &lt;/button&gt; );}function PlayButton({ movieName }) { function handlePlayClick() { alert(`正在播放 ${movieName}！`); } return ( &lt;Button onClick={handlePlayClick}&gt; 播放 &quot;{movieName}&quot; &lt;/Button&gt; );}function UploadButton() { return ( &lt;Button onClick={() =&gt; alert('正在上传！')}&gt; 上传图片 &lt;/Button&gt; );}export default function Toolbar() { return ( &lt;div&gt; &lt;PlayButton movieName=&quot;迪迦奥特曼&quot; /&gt; &lt;UploadButton /&gt; &lt;/div&gt; );} 事件传播行为事件处理函数还会捕获任何来自子组件的事件，即事件从发生的地方开始，沿着 UI 树向上传播。例如： 子组件事件传播行为1234567891011export default function Toolbar() { return ( &lt;div className=&quot;Toolbar&quot; onClick={() =&gt; { alert('你点击了 toolbar ！'); }}&gt; &lt;button onClick={() =&gt; alert('正在播放！')}&gt; 播放电影 &lt;/button&gt; &lt;/div&gt; );} 上述实例中，div 及其子组件 button 均添加了点击事件，虽然行为不同，但是当点击按钮出发其事件处理后，对应的点击事件会沿着UI树向上传播至 div 中，进而触发 div 的点击事件回调其处理函数。所以会看到两次弹窗。但是，这种传播是可以被中断的。每个事件处理函数接收一个 事件对象 作为唯一的参数，可以使用此对象来读取有关事件的信息。同样的，若想阻止事件向上传播，可以在子组件事件处理函数的开始处，借助事件的 e.stopPropagation() 方法实现。（浏览器内置组件可以通过自定义组件来包装一下。） 阻止子组件事件传播行为12345678910function Button({ onClick, children }) { return ( &lt;button onClick={e =&gt; { e.stopPropagation(); // 阻止事件传播至父组件 onClick(); }}&gt; {children} &lt;/button&gt; );} 阻止组件默认行为某些浏览器事件具有与事件相关联的默认行为。例如，点击 &lt;form&gt; 表单内部的按钮会触发表单提交事件，默认情况下将重新加载整个页面，但是这种行为也是可以事件对象的 e.preventDefault() 方法来阻止的： 阻止组件的默认行为1234567891011export default function Signup() { return ( &lt;form onSubmit={e =&gt; { e.preventDefault(); // 阻止组件的默认行为 alert('提交表单！'); }}&gt; &lt;input /&gt; &lt;button&gt;发送&lt;/button&gt; &lt;/form&gt; );} State事件处理函数是执行副作用的最佳位置。同渲染函数不同，事件处理函数不需要是 纯函数，因此它是用来更改某些值的绝佳位置。例如，更改输入框的值以响应键入，或者更改列表以响应按钮的触发。但是，在修改数据前，通常需要记住修改的值，这在 React 中便是通过 State （状态）来实现的。通常情况下，在组件内部使用普通变量保存状态数据后，在事件（例如按钮的点击事件）处理过程中改变其数据后，无法实现新内容的渲染，这是因为： 局部变量无法在多次渲染中持久保存。 当 React 再次渲染组件时，会从头开始渲染，不会考虑之前对局部变量的任何更改。 更改局部变量不会触发渲染。 React 没有意识到它需要使用新数据再次渲染组件。 在 React 中，以上功能可以通过 Hook 函数 useState 实现，该函数接收1个参数，为状态的初始值；返回值可以解构为两个值：其中第一个取值为 状态 ，第二个值为 setter 函数，用于改变状态的取值，进而触发 React 重新渲染组件。 当编写一个存有 state 的组件时，需要考虑使用多少个 state 变量以及它们都是怎样的数据格式。尽管选择次优的 state 结构下也可以编写正确的程序，但有几个原则可以帮助做出更好的决策： 合并关联的 state。如果总是同时更新两个或更多的 state 变量，可以考虑将它们合并为一个单独的 state 变量。 避免互相矛盾的 state。当 state 结构中存在多个相互矛盾或“不一致”的 state 时，就可能为此会留下隐患。应尽量避免这种情况。 避免冗余的 state。如果能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入该组件的 state 中。 避免重复的 state。当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，这会很难保持它们同步。应尽可能减少重复。 避免深度嵌套的 state。深度分层的 state 更新起来不是很方便。如果可能的话，最好以扁平化方式构建 state。 添加一个 state 变量要添加 state 变量，先从文件顶部的 React 中导入 useState： 导入 useState Hook1import { useState } from 'react'; 然后接收 Hook 返回的两个值，这两个取值是相互对应的： 解构 useState 的返回值1const [state, setXxx] = useState(inieState); 官网提供的完整实例如下： 官方示例1234567891011121314151617181920212223242526272829303132333435import { useState } from 'react';import { sculptureList } from './data.js';export default function Gallery() { const [index, setIndex] = useState(0); function handleClick() { // React 会记住中间值 // 即使再次渲染时看到的仍是初始值，但是会使用中间值进行相应的渲染 setIndex(index + 1); } let sculpture = sculptureList[index]; return ( &lt;&gt; &lt;button onClick={handleClick}&gt; Next &lt;/button&gt; &lt;h2&gt; &lt;i&gt;{sculpture.name} &lt;/i&gt; by {sculpture.artist} &lt;/h2&gt; &lt;h3&gt; ({index + 1} of {sculptureList.length}) &lt;/h3&gt; &lt;img src={sculpture.url} alt={sculpture.alt} /&gt; &lt;p&gt; {sculpture.description} &lt;/p&gt; &lt;/&gt; );} Hooks ——以 use 开头的函数——只能在组件或自定义 Hook 的最顶层调用。 你不能在条件语句、循环语句或其他嵌套函数内调用 Hook。Hook 是函数，但将它们视为关于组件需求的无条件声明会很有帮助。在组件顶部 “use” React 特性，类似于在文件顶部“导入”模块。 React 文档 – state 组件的记忆 每个组件可以同时定义多个不同的 state ，不会相互影响。但如果发现经常同时更改多个 state 变量，那么可以由一个值为对象的 state 变量的多个字段对应一个 state 变量，在事件处理过程中，通过更改对象的相应字段即可。 State 是隔离且私有的 State 是屏幕上组件实例内部的状态。换句话说，如果你渲染同一个组件两次，每个副本都会有完全隔离的 state！改变其中一个不会影响另一个。 React 文档 – state 组件的记忆 渲染和提交在 React 中，UI 的更新通常有三个步骤： 触发一次渲染 初次渲染。应用启动时，会触发初次渲染。这个过程通过调用目标 DOM 节点的 createRoot，然后再调用组件调用 render 函数完成。 状态更新时重新渲染。一旦组件被初次渲染，就可以通过使用 setter 函数更新其状态来触发之后的渲染。更新组件的状态会自动将一次渲染送入队列。 set 函数 仅更新 下一次 要渲染的状态变量。如果在调用 setter 函数后读取状态变量，则还是会看到之前的旧值；如果提供的新值与当前 state 相同，则不会触发对应组件及子组件的渲染。 React 渲染组件 在进行初次渲染时, React 会调用根组件。 对于后续的渲染, React 会调用内部状态更新触发了渲染的函数组件。 这个过程是递归的：如果更新后的组件会返回某个另外的组件，那么 React 接下来就会渲染返回的组件，而如果返回的组件又返回了某个组件，那么 React 接下来就会渲染继续渲染后续返回的组件，以此类推。这个过程会持续下去，直到没有更多的嵌套组件并且 React 确切知道哪些东西应该显示到屏幕上为止。 React 把更改提交到 DOM 上 对于初次渲染， React 会使用 appendChild() DOM API 将其创建的所有 DOM 节点放在屏幕上。 对于重渲染， React 将应用最少的必要操作（在渲染时计算。），以使得 DOM 与最新的渲染输出相互匹配。 state 的进一步理解state 如同一张快照 是官方对 state 的一个描述。据此，每次状态变化触发渲染时，渲染的结果都是根据上一次渲染后的结果计算得到。因此，即使在事件处理时多次根据状态的值计算的下一次渲染状态，得到的结果都是相同的。例如： 根据快照 number 计算下一次渲染的结果1234567891011121314151617import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 1); setNumber(number + 1); setNumber(number + 1); }}&gt;+3&lt;/button&gt; &lt;/&gt; )} 上述官方示例中，虽然在按钮的事件处理函数中对 number 状态连续做了三次加一，但是因为都是基于上一次渲染结果的快照（即组件加载时的 0）计算更新，所以最终在下一次渲染时，number 的值为 1，而非 3。另一方面，根据官方文档： 一个 state 变量的值永远不会在一次渲染的内部发生变化， 即使其事件处理函数的代码是异步的。 React 文档 – state 如同一张快照 在一个新的场景下，如果先对状态进行更新，触发组件重新渲染以后，在直接使用对应的状态（例如弹窗显示等），实际上使用的值是上一次渲染的快照值。 渲染组建后随机使用状态做弹窗123456789101112131415import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 5); alert(number); }}&gt;+5&lt;/button&gt; &lt;/&gt; )} 多次更新状态值 React 会等到事件处理函数中的 所有 代码都运行完毕再处理你的 state 更新。 React 文档 – 把一系列 state 更新加入队列 实际上，事件处理函数及其中任何代码执行完成 之后，UI 才会更新，也就是所谓的批处理，这可以保证渲染结果的正确性。在上一节中的示例中，更新状态值都是基于快照的值进行的，而传递给更新函数的都是计算后的值。有时候需要连续多次的对状态的值进行更新，例如，这种场景下，可以传入一个函数给到设值函数，这样一个更新函数接收相应的参数，用于累积结果： 根据更新队列中的值 n，计算后续更新的值12345678910111213141516import { useState } from 'react';export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 5); setNumber(n =&gt; n + 1); }}&gt;增加数字&lt;/button&gt; &lt;/&gt; )} 更新 state 中的对象及数组在 React 中，如果状态对应的是一个对象或者数组，如果单纯相应对象的某个属性发生变化，是不会通知到 React 进行重新渲染的。只有通过设值函数利用修改后的 新对象 或者 新数组 更新状态，让 React 感知到相应变化，才能触发组件的重新渲染。总体上，把握一个原则， 不要妄想直接改变原有对象触发渲染，不管什么时候，要想React重新渲染组件，就通过复制或者能够返回一个新对象/数组的函数，传递一个全新的状态至对应状态的设置函数 。例如： 传递一个新的对象，触发渲染并更新红点位置1234567891011121314151617181920212223242526272829303132import { useState } from 'react';export default function MovingDot() { const [position, setPosition] = useState({ x: 0, y: 0 }); return ( &lt;div onPointerMove={e =&gt; { setPosition({ // 传入一个新的对象 x: e.clientX, y: e.clientY }); }} style={{ position: 'relative', width: '100vw', height: '100vh', }}&gt; &lt;div style={{ position: 'absolute', backgroundColor: 'red', borderRadius: '50%', transform: `translate(${position.x}px, ${position.y}px)`, left: -10, top: -10, width: 20, height: 20, }} /&gt; &lt;/div&gt; );} 如果对象比较复杂，可以使用 展开语法 进行对象复制： 展开语法复制对象/数组1234567891011// 复制对象setPerson({ ...person, // 复制上一个 person 中的所有字段 firstName: e.target.value // 但是覆盖 firstName 字段 });// 复制数组setArtists([{ id: nextId++, name: name }, ...artists // 将原数组中的元素放在末尾 ]); 如果对象比较复杂，数据一些逻辑较为啰嗦，可以利用 Immer 库简化相应的更新操作。添加相应的依赖： immer 依赖12345678910111213141516{ &quot;dependencies&quot;: { &quot;immer&quot;: &quot;1.7.3&quot;, &quot;react&quot;: &quot;latest&quot;, &quot;react-dom&quot;: &quot;latest&quot;, &quot;react-scripts&quot;: &quot;latest&quot;, &quot;use-immer&quot;: &quot;0.5.1&quot; }, &quot;scripts&quot;: { &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; }, &quot;devDependencies&quot;: {}} Immer 使用举例： Immer 用法123456789101112131415161718192021222324252627282930313233343536373839import { useState } from 'react';import { useImmer } from 'use-immer';const initialList = [ { id: 0, title: 'Big Bellies', seen: false }, { id: 1, title: 'Lunar Landscape', seen: false }, { id: 2, title: 'Terracotta Army', seen: true },];...export default function BucketList() { const [myList, updateMyList] = useImmer( initialList ); function handleToggleMyList(id, nextSeen) { updateMyList(draft =&gt; { const artwork = draft.find(a =&gt; a.id === id ); artwork.seen = nextSeen; }); } return ( &lt;&gt; &lt;h1&gt;艺术愿望清单&lt;/h1&gt; &lt;h2&gt;我想看的艺术清单：&lt;/h2&gt; &lt;ItemList artworks={myList} onToggle={handleToggleMyList} /&gt; &lt;h2&gt;你想看的艺术清单：&lt;/h2&gt; &lt;ItemList artworks={yourList} onToggle={handleToggleYourList} /&gt; &lt;/&gt; );}...","link":"/2024/03/framworks/front_framworks/react/event-response-and-single-comp-state/"},{"title":"React 利用Reducer管理复杂状态及Context深层传递状态","text":"迁移状态逻辑至 Reducer 中随着组件复杂度的增加，将很难一眼看清所有的组件状态更新逻辑。例如，下面的 TaskApp 组件有一个数组类型的状态 tasks，并通过三个不同的事件处理程序来实现任务的添加、删除和修改： 多事件处理程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import { useState } from 'react';import AddTask from './AddTask.js';import TaskList from './TaskList.js';export default function TaskApp() { const [tasks, setTasks] = useState(initialTasks); function handleAddTask(text) { setTasks([ ...tasks, { id: nextId++, text: text, done: false, }, ]); } function handleChangeTask(task) { setTasks( tasks.map((t) =&gt; { if (t.id === task.id) { return task; } else { return t; } }) ); } function handleDeleteTask(taskId) { setTasks(tasks.filter((t) =&gt; t.id !== taskId)); } return ( &lt;&gt; &lt;h1&gt;布拉格的行程安排&lt;/h1&gt; &lt;AddTask onAddTask={handleAddTask} /&gt; &lt;TaskList tasks={tasks} onChangeTask={handleChangeTask} onDeleteTask={handleDeleteTask} /&gt; &lt;/&gt; );}let nextId = 3;const initialTasks = [ {id: 0, text: '参观卡夫卡博物馆', done: true}, {id: 1, text: '看木偶戏', done: false}, {id: 2, text: '打卡列侬墙', done: false},]; 这个组件的每个事件处理程序都通过 setTasks 来更新状态。随着这个组件的不断迭代，其状态逻辑也会越来越多。为了降低这种复杂度，并让所有逻辑都可以存放在一个易于理解的地方，可以通过三个步骤将逻辑移到组件之外的一个称为 reducer 的函数中（useReducer）： 将设置状态的逻辑 修改 成 dispatch 的一个 action 编写 一个 reducer 函数 在组件中 使用 reducer 将设置状态的逻辑修改分派方式移除所有的状态设置逻辑。只留下三个事件处理函数： handleAddTask(text) 在用户点击 “添加” 时被调用。 handleChangeTask(task) 在用户切换任务或点击 “保存” 时被调用。 handleDeleteTask(taskId) 在用户点击 “删除” 时被调用。 使用 reducers 管理状态与直接设置状态略有不同。它不是通过设置状态来告诉 React “要做什么”，而是通过事件处理程序分派一个带着不同行为的 Flag 来指明 “用户刚刚做了什么”，以及如何处理该事件。 事件处理程序分派123456789101112131415161718192021function handleAddTask(text) { dispatch({ type: 'added', id: nextId++, text: text, }); } function handleChangeTask(task) { dispatch({ type: 'changed', task: task, }); } function handleDeleteTask(taskId) { dispatch({ type: 'deleted', id: taskId, }); } 编写一个 reducer 函数所谓 reducer 函数就是放置状态处理逻辑的地方。它接受两个参数，分别为当前 state 和 action 对象，并且返回的是更新后的 state。React 会将状态设置为从 reducer 返回的状态。在当前例子中，可以通过如下步骤将状态设置逻辑从事件处理程序移到 reducer 函数中： 声明当前状态（tasks）作为第一个参数； 声明 action 对象作为第二个参数； 从 reducer 返回 下一个 状态（React 会将旧的状态设置为这个最新的状态）。 事件分派123456789101112131415161718192021222324function tasksReducer(tasks, action) { if (action.type === 'added') { return [ ...tasks, { id: action.id, text: action.text, done: false, }, ]; } else if (action.type === 'changed') { return tasks.map((t) =&gt; { if (t.id === action.task.id) { return action.task; } else { return t; } }); } else if (action.type === 'deleted') { return tasks.filter((t) =&gt; t.id !== action.id); } else { throw Error('未知 action: ' + action.type); } } 在组件中使用 reducer最后，需要将 tasksReducer 导入到组件中。以替换掉之前的 useState： 使用 reducer123456import { useReducer } from 'react';// 删除状态const [tasks, setTasks] = useState(initialTasks);// 改用 reducerconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks); 使用 useReducer时，必须给它传递一个初始状态，它会返回一个有状态的值和一个设置该状态的函数（在这个例子中就是 dispatch 函数）。useReducer 钩子接受 2 个参数： 一个 reducer 函数 一个初始的 state 然后返回如下内容： 一个有状态的值 一个 dispatch 函数（用来 “派发” 用户操作给 reducer） 这样，事件处理程序只通过派发不同的 action 来指定 发生了什么，而 reducer 函数通过响应不同的 actions 来决定 状态如何更新。 对比 useState 和 useReducer 代码体积： 通常，在使用 useState 时，一开始只需要编写少量代码。而 useReducer 必须提前编写 reducer 函数和需要调度的 actions。但是，当多个事件处理程序以相似的方式修改 state 时，useReducer 可以减少代码量。 可读性： 当状态更新逻辑足够简单时，useState 的可读性还行。但是，一旦逻辑变得复杂起来，它们会使组件变得臃肿且难以阅读。在这种情况下，useReducer 允许将状态更新逻辑与事件处理程序分离开来。 可调试性： 当使用 useState 出现问题时, 很难发现具体原因以及为什么。 而使用 useReducer 时， 可以在 reducer 函数中通过打印日志的方式来观察每个状态的更新，以及为什么要更新（来自哪个 action）。 如果所有 action 都没问题，就知道问题出在了 reducer 本身的逻辑中。 然而，与使用 useState 相比，必须单步执行更多的代码。 可测试性： reducer 是一个不依赖于组件的纯函数。这就意味着可以单独对它进行测试。一般来说，最好是在真实环境中测试组件，但对于复杂的状态更新逻辑，针对特定的初始状态和 action，断言 reducer 返回的特定状态会很有帮助。 如何编写一个好的 reducers reducers 必须是纯粹的。 这一点和状态更新函数是相似的，reducers 在是在渲染时运行的！（actions 会排队直到下一次渲染)。 这就意味着 reducers 必须无副作用，即当输入相同时，输出也是相同的。它们不应该包含异步请求、定时器或者任何副作用（对组件外部有影响的操作）。它们应该以不可变值的方式去更新对象和数组。 每个 action 都描述了一个单一的用户交互，即使它会引发数据的多个变化。 举个例子，如果用户在一个由 reducer 管理的表单（包含五个表单项）中点击了 重置按钮，那么 dispatch 一个 reset_form 的 action 比 dispatch 五个单独的 set_field 的 action 更加合理。如果在一个 reducer 中打印了所有的 action 日志，那么这个日志应该是很清晰的，它能以某种步骤复现已发生的交互或响应。这对代码调试很有帮助。 使用 Context 深层传递参数传递 props 是将数据通过 UI 树显式传递到使用它的组件的常用方法，但是当需要在组件树中深层传递参数以及需要在组件间复用相同的参数时，传递 props 就会变得很麻烦。最近的根节点父组件可能离需要数据的组件很远，状态提升到太高的层级会导致 “逐层传递 props” 的情况。 此时，利用 Context 允许父组件向其下层无论多深的任何组件提供信息，而无需通过 props 显式传递。 Context：传递 propsContext 让父组件可以为它下面的整个组件树提供数据。官网示例主题App如下： Context示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import Heading from './Heading.js';import Section from './Section.js';export default function Page() { return ( &lt;Section&gt; &lt;Heading level={1}&gt;主标题&lt;/Heading&gt; &lt;Section&gt; &lt;Heading level={2}&gt;副标题&lt;/Heading&gt; &lt;Heading level={2}&gt;副标题&lt;/Heading&gt; &lt;Heading level={2}&gt;副标题&lt;/Heading&gt; &lt;Section&gt; &lt;Heading level={3}&gt;子标题&lt;/Heading&gt; &lt;Heading level={3}&gt;子标题&lt;/Heading&gt; &lt;Heading level={3}&gt;子标题&lt;/Heading&gt; &lt;Section&gt; &lt;Heading level={4}&gt;子子标题&lt;/Heading&gt; &lt;Heading level={4}&gt;子子标题&lt;/Heading&gt; &lt;Heading level={4}&gt;子子标题&lt;/Heading&gt; &lt;/Section&gt; &lt;/Section&gt; &lt;/Section&gt; &lt;/Section&gt; );}export function Section({ children }) { return ( &lt;section className=&quot;section&quot;&gt; {children} &lt;/section&gt; );}export function Heading({ level, children }) { switch (level) { case 1: return &lt;h1&gt;{children}&lt;/h1&gt;; case 2: return &lt;h2&gt;{children}&lt;/h2&gt;; case 3: return &lt;h3&gt;{children}&lt;/h3&gt;; case 4: return &lt;h4&gt;{children}&lt;/h4&gt;; case 5: return &lt;h5&gt;{children}&lt;/h5&gt;; case 6: return &lt;h6&gt;{children}&lt;/h6&gt;; default: throw Error('未知的 level：' + level); }} 此示例可以改为将 level 参数传递给 &lt;Section&gt; 组件而不是传给 &lt;Heading&gt; 组件，以强制使同一个 section 中的所有标题都有相同的尺寸： 状态提升12345&lt;Section level={3}&gt; &lt;Heading&gt;关于&lt;/Heading&gt; &lt;Heading&gt;照片&lt;/Heading&gt; &lt;Heading&gt;视频&lt;/Heading&gt; &lt;/Section&gt; 但是当 Section 组件嵌套使用并且不同层级下的标题有不同的级别时，就需要知道离 Heading 最近的 Section 是谁才能够实现目的，这就可以通过 context 来实现： 创建 一个 context。（可以将其命名为 LevelContext, 因为它表示的是标题级别。) 在需要数据的组件内 使用 刚刚创建的 context。（Heading 将会使用 LevelContext。） 在指定数据的组件中 提供 这个 context。 （Section 将会提供 LevelContext。） 这样，Context 可以让父节点，甚至是很远的父节点都可以为其内部的整个组件树提供数据： 创建 context首先，创建 context： Context 创建123import { createContext } from 'react';export const LevelContext = createContext(1); createContext 只需默认值一个参数。在这里, 1 表示最大的标题级别，但可以传递任何类型的值（甚至可以传入一个对象）。 使用 Context然后，从 Heading 组件的 props 中删掉 level 参数并从 LevelContext 中读取值： 从 Context 中读取值12345export default function Heading({ children }) { const level = useContext(LevelContext); // ... } useContext 是一个 Hook，只能在 React 组件中（不是循环或者条件里）立即调用 Hook。**useContext 告诉 React Heading 组件想要读取 LevelContext**。如此一来 Heading 组件就无需传递 level 参数，而是让 Section 组件代替 Heading 组件接收 level 参数： 通过 Section 接收 level 参数12345&lt;Section level={4}&gt; &lt;Heading&gt;子子标题&lt;/Heading&gt; &lt;Heading&gt;子子标题&lt;/Heading&gt; &lt;Heading&gt;子子标题&lt;/Heading&gt; &lt;/Section&gt; 提供 context最后，需要提供正在使用 context，因为当前 React 还不知道从哪里获取这个 context。Section 组件目前渲染传入它的子组件： Section渲染子组件1234567export default function Section({ children }) { return ( &lt;section className=&quot;section&quot;&gt; {children} &lt;/section&gt; ); } 需要用 context provider 将子组件包裹起来以提供 LevelContext 给 Section 的子组件： 为子组件提供 Context123456789export function Section({ level, children }) { return ( &lt;section className=&quot;section&quot;&gt; &lt;LevelContext.Provider value={level}&gt; {children} &lt;/LevelContext.Provider&gt; &lt;/section&gt; ); } 这告诉 React：“如果在 &lt;Section&gt; 组件中的任何子组件请求 LevelContext，则给他们这个 level。” 组件会使用 UI 树中在它上层最近的那个 &lt;LevelContext.Provider&gt; 传递过来的值。此外，可以在提供 context 的组件和使用它的组件之间的层级插入任意数量的组件。这包括像 &lt;div&gt; 这样的内置组件和自己创建的组件。 使用 context 之前 从传递 props 开始。 如果组件看起来不起眼，那么通过十几个组件向下传递一堆 props 并不罕见。这有点像是在埋头苦干，但是这样做可以让哪些组件用了哪些数据变得十分清晰！ 抽象组件并将 JSX 作为 children 传递 给它们。 如果通过很多层不使用该数据的中间组件（并且只会向下传递）来传递数据，这通常意味着在此过程中可以使用抽象组件。举个例子，有时可能想传递一些像 posts 的数据 props 到不会直接使用这个参数的组件，类似 &lt;Layout posts={posts} /&gt;。取而代之的是，让 Layout 把 children 当做一个参数，然后渲染 &lt;Layout&gt;&lt;Posts posts={posts} /&gt;&lt;/Layout&gt;。这样就减少了定义数据的组件和使用数据的组件之间的层级。 Context 的使用场景 主题： 如果应用允许用户更改其外观（例如暗夜模式），可以在应用顶层放一个 context provider，并在需要调整其外观的组件中使用该 context。 当前账户： 许多组件可能需要知道当前登录的用户信息。将它放到 context 中可以方便地在树中的任何位置读取它。某些应用还允许同时操作多个账户（例如，以不同用户的身份发表评论）。在这些情况下，将 UI 的一部分包裹到具有不同账户数据的 provider 中会很方便。 路由： 大多数路由解决方案在其内部使用 context 来保存当前路由。这就是每个链接“知道”它是否处于活动状态的方式。 状态管理： 随着应用的增长，最终在靠近应用顶部的位置可能会有很多 state。许多遥远的下层组件可能想要修改它们。通常将 reducer 与 context 搭配使用来管理复杂的状态并将其传递给深层的组件来避免过多的麻烦。 总结在组件状态较为复杂时，可以通过 Reducer 整合相近行为的事件处理函数，通过事件分派的方式，减少需要管理的状态个数。如果需要远距离向下共享状态，则可以通过 Context 实现。","link":"/2024/03/framworks/front_framworks/react/reducer-state-mgr-and-context/"},{"title":"React Ref 建立虚拟与真实Dom的链接","text":"使用 ref 引用值当希望组件“记住”某些信息，但又不想让这些信息触发新的渲染时，可以使用 ref 来实现。使用时，可以通过从 React 导入 useRef Hook 来为组件添加一个 ref： 为组件创建 ref12345678import { useRef } from 'react';const ref = useRef(0);// 此 Hook 返回一个对象，其中保存传入的取值{ current: 0} 之后，就可以使用 ref.current 属性访问该 ref 的当前值。这个值在 React 中被有意设置为可变的，意味着可以对它进行读写操作。像 state 一样，可以让它指向任何东西：字符串、对象，甚至是函数。但与 state 不同的是，ref 是一个普通的 JavaScript 对象，并且在 ref 值更新时，组件不会被重新渲染。因此，如果在更新取值后，若需要重新渲染组件才会显示新状态的场景，ref 并不是一个合适的选择，因为界面永远不会被刷新。 ref 和 state 的比较在大多数情况下，React 官方建议使用 state，ref 并不常用。 ref state useRef(initialValue)返回 { current: initialValue } useState(initialValue) 返回 state 变量的当前值和一个 state 设置函数 ( [value, setValue]) 更改时不会触发重新渲染 更改时触发重新渲染。 可变 —— 可以在渲染过程之外修改和更新 current 的值。 “不可变” —— 必须使用 state 设置函数来修改 state 变量，从而排队重新渲染。 不应在渲染期间读取（或写入） current 值。 可以随时读取 state。但是，每次渲染都有自己不变的 state 快照。 何时使用 ref通常，当组件需要“跳出” React 并与外部 API 通信时，会用到 ref —— 通常是不会影响组件外观的浏览器 API。以下是这些罕见情况中的几个： 存储 timeout ID 存储和操作DOM 元素 存储不需要被用来计算 JSX 的其他对象。 如果组件需要存储一些值，但不影响渲染逻辑，可以选择 ref。 ref 的最佳实践 将 ref 视为脱围机制。当使用外部系统或浏览器 API 时，ref 很有用。如果很大一部分应用程序逻辑和数据流都依赖于 ref，则可能需要重新考虑实现的方法。 不要在渲染过程中读取或写入 ref.current。 如果渲染过程中需要某些信息，请使用 state 代替。由于 React 不知道 ref.current 何时发生变化，即使在渲染时读取它也会使组件的行为难以预测。（唯一的例外是像 if (!ref.current) ref.current = new Thing() 这样的代码，它只在第一次渲染期间设置一次 ref。） 使用 ref 操作 Domref 最常见的用法是访问 DOM 元素，例如，如果想以编程方式聚焦一个输入框，这种用法就会派上用场。当将 ref 传递给 JSX 中的 ref 属性时，比如 &lt;div ref={myRef}&gt;，React 会将相应的 DOM 元素放入 myRef.current 中。当元素从 DOM 中删除时，React 会将 myRef.current 更新为 null。下面总结如何使用 ref 来操作 Dom。 获取指向节点的 ref","link":"/2024/03/framworks/front_framworks/react/ref-bridge-between-virtual-real-dom/"},{"title":"React 在组件间共享状态","text":"状态共享的一个例子要实现两个组件的状态始终同步更改，可以将相关 state 从这两个组件上移除，并把 state 放到它们的公共父级，再通过 props 将 state 传递给这两个组件。这个操作被称为“状态提升”。共享状态的场景在前端开发中非常常见，这里整理官网提供的状态提升示例，进一步巩固状态提升的掌握。示例如下： 状态提升前1234567891011121314151617181920212223242526272829303132import { useState } from 'react';function Panel({ title, children }) { const [isActive, setIsActive] = useState(false); return ( &lt;section className=&quot;panel&quot;&gt; &lt;h3&gt;{title}&lt;/h3&gt; {isActive ? ( &lt;p&gt;{children}&lt;/p&gt; ) : ( &lt;button onClick={() =&gt; setIsActive(true)}&gt; 显示 &lt;/button&gt; )} &lt;/section&gt; );}export default function Accordion() { return ( &lt;&gt; &lt;h2&gt;哈萨克斯坦，阿拉木图&lt;/h2&gt; &lt;Panel title=&quot;关于&quot;&gt; 阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。 &lt;/Panel&gt; &lt;Panel title=&quot;词源&quot;&gt; 这个名字来自于 &lt;span lang=&quot;kk-KZ&quot;&gt;алма&lt;/span&gt;，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，&lt;i lang=&quot;la&quot;&gt;Malus sieversii&lt;/i&gt; 被认为是现今苹果的祖先。 &lt;/Panel&gt; &lt;/&gt; );} 上述示例中，父组件 Accordion 渲染了 2 个独立的 Panel 组件，每个 Panel 组件都有一个布尔值 isActive，用于独立的控制组件自己的内容是否可见。假设想改变这种行为，以便在任何时候只展开一个面板。这个时候，isActive 就不能放置于组件自身，需要将其提升至父组件中，以便可以将 isActive 状态共享给两个子组件。这可以通过如下三步实现： 从子组件中 移除 state 。 从父组件 传递 硬编码数据。 为共同的父组件添加 state ，并将其与事件处理函数一起向下传递。 从子组件中移除状态首先，将 Panel 组件对 isActive 的控制权交给他们的父组件，由父组件将 isActive 作为 prop 传给子组件 Panel。因此，先从 Panel 组件中删除 isActive 状态，并把 isActive 加入 Panel 组件的 props 中： 移除子组件 isActive 状态12345// 从子组件中删除这一行const [isActive, setIsActive] = useState(false);// 子组件的 props 中加入 isActivefunction Panel({ title, children, isActive }){ ... } 从公共父组件传递硬编码数据然后，为了实现状态提升，须定位到想协调的两个子组件最近的公共父组件： Accordion (最近的公共父组件) Panel Panel 在这个示例中，最近的公共父组件是 Accordion。因为它位于两个面板之上，可以控制两个子组件的 props，所以它将成为当前激活面板的“控制之源”。这里通过 Accordion 组件将 isActive 硬编码值（例如 true ）传递给两个面板，可以看到不同取值下两个子组件的行为： 传递 isActive 的硬编码状态给两个子组件123456789101112131415161718192021222324252627282930import { useState } from 'react';export default function Accordion() { return ( &lt;&gt; &lt;h2&gt;哈萨克斯坦，阿拉木图&lt;/h2&gt; &lt;Panel title=&quot;关于&quot; isActive={true}&gt; 阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。 &lt;/Panel&gt; &lt;Panel title=&quot;词源&quot; isActive={true}&gt; 这个名字来自于 &lt;span lang=&quot;kk-KZ&quot;&gt;алма&lt;/span&gt;，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，&lt;i lang=&quot;la&quot;&gt;Malus sieversii&lt;/i&gt; 被认为是现今苹果的祖先。 &lt;/Panel&gt; &lt;/&gt; );}function Panel({ title, children, isActive }) { return ( &lt;section className=&quot;panel&quot;&gt; &lt;h3&gt;{title}&lt;/h3&gt; {isActive ? ( &lt;p&gt;{children}&lt;/p&gt; ) : ( &lt;button onClick={() =&gt; setIsActive(true)}&gt; 显示 &lt;/button&gt; )} &lt;/section&gt; );} 为公共父组件添加状态状态提升通常会改变原状态的数据存储类型，以便子组件更加精确的识别想要的行为，但是改变并不是必须的，本示例就是如此。但在官网的示例中，改用数字作为当前被激活 Panel 的索引，而不是 boolean 值，即当 activeIndex 为 0 时，激活第一个面板，为 1 时，激活第二个面板。另一方面，在任意一个 Panel 中点击“显示”按钮都需要更改 Accordion 中的激活索引值。但在 Panel 中无法直接设置状态 activeIndex 的值，因为该状态是在 Accordion 组件内部定义的。不过Accordion 组件需要可以 显式允许 Panel 组件通过 将事件处理程序作为 prop 向下传递 来更改其状态父组件中的状态： 父组件传递共享 isActive 状态及设值函数123456789101112131415161718192021222324252627282930313233343536373839404142434445import { useState } from 'react';export default function Accordion() { const [activeIndex, setActiveIndex] = useState(0); return ( &lt;&gt; &lt;h2&gt;哈萨克斯坦，阿拉木图&lt;/h2&gt; &lt;Panel title=&quot;关于&quot; isActive={activeIndex === 0} onShow={() =&gt; setActiveIndex(0)} &gt; 阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。 &lt;/Panel&gt; &lt;Panel title=&quot;词源&quot; isActive={activeIndex === 1} onShow={() =&gt; setActiveIndex(1)} &gt; 这个名字来自于 &lt;span lang=&quot;kk-KZ&quot;&gt;алма&lt;/span&gt;，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，&lt;i lang=&quot;la&quot;&gt;Malus sieversii&lt;/i&gt; 被认为是现今苹果的祖先。 &lt;/Panel&gt; &lt;/&gt; );}function Panel({ title, children, isActive, onShow}) { return ( &lt;section className=&quot;panel&quot;&gt; &lt;h3&gt;{title}&lt;/h3&gt; {isActive ? ( &lt;p&gt;{children}&lt;/p&gt; ) : ( &lt;button onClick={onShow}&gt; 显示 &lt;/button&gt; )} &lt;/section&gt; );} 每个状态都对应唯一的数据源需要注意的是：对于每个独特的状态，都应该存在且只存在于一个指定的组件中作为 state。这一原则也被称为拥有 “可信单一数据源”。它并不意味着所有状态都存在一个地方——对每个状态来说，都需要一个特定的组件来保存这些状态信息。应该 将状态提升 到公共父级，或 将状态传递 到需要它的子级中，而不是在组件之间复制共享的状态。此外，应用会随着操作而变化。当将状态上下移动时，依然会需要确定每个状态在哪里“活跃”。 state 的保留和重置状态与渲染树中的位置相关虽说各个组件的 state 是各自独立的，但是这些状态是保存在 React 中的，React 可以跟踪组件在渲染树中的位置将它保存的每个状态与正确的组件关联起来。开发过程中，可以控制在重新渲染过程中何时对 state 进行保留和重置。例如： 组件状态与位置12345678910111213141516171819202122232425262728293031323334import { useState } from 'react';export default function App() { const counter = &lt;Counter /&gt;; return ( &lt;div&gt; {counter} {counter} &lt;/div&gt; );}function Counter() { const [score, setScore] = useState(0); const [hover, setHover] = useState(false); let className = 'counter'; if (hover) { className += ' hover'; } return ( &lt;div className={className} onPointerEnter={() =&gt; setHover(true)} onPointerLeave={() =&gt; setHover(false)} &gt; &lt;h1&gt;{score}&lt;/h1&gt; &lt;button onClick={() =&gt; setScore(score + 1)}&gt; 加一 &lt;/button&gt; &lt;/div&gt; );} 在上述示例代码中，两个 counter 对象被先后两次渲染，尽管看上去是同一个对象，但是在 UI 树中，可以理解为原始对象的副本，而对应节点的状态则是由位置决定，React 根据位置关联对应的组件虚拟 Dom。前面文章提到过，状态是相互隔离的。因此，在此例子中，若点击各自组件的计数按钮，会发现两个组件计数器独自变化。下图为部分 UI 树： 此外，只有当在树中相同的位置渲染相同的组件时，React 才会一直保留着组件的 state。可以增加一个复选框，控制第二个计数器的是否渲染，将两个计数器的值递增，然后取消勾选 “渲染第二个计数器” 复选框，接着再次勾选它。可以发现，第二个组件的计数在重新勾选后，会从0开始。 增加复选框控制第二个组件渲染1234567891011121314151617181920export default function App() { const [showB, setShowB] = useState(true); return ( &lt;div&gt; &lt;Counter /&gt; {showB &amp;&amp; &lt;Counter /&gt;} &lt;label&gt; &lt;input type=&quot;checkbox&quot; checked={showB} onChange={e =&gt; { setShowB(e.target.checked) }} /&gt; 渲染第二个计数器 &lt;/label&gt; &lt;/div&gt; );}... 相同位置的相同组件会使得 state 被保留下来不过有一点乍一看可能与上述描述不一致，第一个组件如果被再次被渲染，只要该组件还被渲染在 UI 树的相同位置，React 就会保留它的 state。 这个相同位置指的是其在UI树中的位置，与在 jsx 代码中的位置无关。举个例子： 两个组件在同一位置被渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import { useState } from 'react';export default function App() { const [isFancy, setIsFancy] = useState(false); return ( &lt;div&gt; {isFancy ? ( &lt;Counter isFancy={true} /&gt; ) : ( &lt;Counter isFancy={false} /&gt; )} &lt;label&gt; &lt;input type=&quot;checkbox&quot; checked={isFancy} onChange={e =&gt; { setIsFancy(e.target.checked) }} /&gt; 使用好看的样式 &lt;/label&gt; &lt;/div&gt; );}function Counter({ isFancy }) { const [score, setScore] = useState(0); const [hover, setHover] = useState(false); let className = 'counter'; if (hover) { className += ' hover'; } if (isFancy) { className += ' fancy'; } return ( &lt;div className={className} onPointerEnter={() =&gt; setHover(true)} onPointerLeave={() =&gt; setHover(false)} &gt; &lt;h1&gt;{score}&lt;/h1&gt; &lt;button onClick={() =&gt; setScore(score + 1)}&gt; 加一 &lt;/button&gt; &lt;/div&gt; );} 当勾选或清空复选框的时候，计数器 state 并没有被重置。不管 isFancy 是 true 还是 false，根组件 App 返回的 div 的第一个子组件都是 &lt;Counter /&gt;，因为是位于相同位置的相同组件，所以对 React 来说，它是同一个计数器。这也就是说，在UI树中相同位置，渲染同类型组件，就会被视为同一个组件被渲染，同时相应的状态得以保留。与之不同的是，如果在相同位置渲染不同类型组件，则会使 state 重置，包括该组件的整个子树都会被重置 。一般来说，如果想在重新渲染时保留 state，几次渲染中的树形结构就应该相互“匹配”。结构不同会 React 在将一个组件从树中移除时销毁它的 state。因此，永远要将组件定义在最上层，并且在组件内部嵌套定义组件 。 在相同位置重置 state默认情况下，React 会在一个组件保持在同一位置时保留它的 state。但有时候，可能想要重置一个组件的 state。这里有两个方法可以实现重置 state： 将组件渲染在不同的位置（界面显示效果，实际在UI树中可能为左右不同位置） 使用 key 赋予每个组件一个明确的身份 方法一比较简单，将组件渲染放置与独立的作用域内就可以实现。主要看方法二，这是最通用的方法。在 渲染列表 时，通常会指定一个合适的 key ，但 key 不只可以用于列表！还可以使用 key 来让 React 区分任何组件。默认情况下，React 使用父组件内部的顺序（“第一个计数器”、“第二个计数器”）来区分组件。但是 key 可以告诉 React 这不仅仅是 第一个 或者 第二个 计数器，还是一个特定的计数器。这样，在不同组件之间切换便不会使 state 被保留下来，例如如下示例： 为不同组件指定对应的key123456789101112131415161718192021222324252627282930313233343536373839404142import { useState } from 'react';export default function Scoreboard() { const [isPlayerA, setIsPlayerA] = useState(true); return ( &lt;div&gt; {isPlayerA ? ( &lt;Counter key=&quot;Taylor&quot; person=&quot;Taylor&quot; /&gt; ) : ( &lt;Counter key=&quot;Sarah&quot; person=&quot;Sarah&quot; /&gt; )} &lt;button onClick={() =&gt; { setIsPlayerA(!isPlayerA); }}&gt; 下一位玩家！ &lt;/button&gt; &lt;/div&gt; );}function Counter({ person }) { const [score, setScore] = useState(0); const [hover, setHover] = useState(false); let className = 'counter'; if (hover) { className += ' hover'; } return ( &lt;div className={className} onPointerEnter={() =&gt; setHover(true)} onPointerLeave={() =&gt; setHover(false)} &gt; &lt;h1&gt;{person} 的分数：{score}&lt;/h1&gt; &lt;button onClick={() =&gt; setScore(score + 1)}&gt; 加一 &lt;/button&gt; &lt;/div&gt; );} 指定一个 key 能够让 React 将 key 本身而非它们在父组件中的顺序作为位置的一部分。这就是为什么尽管用 JSX 将组件渲染在相同位置，但在 React 看来它们是两个不同的计数器。因此它们永远都不会共享 state。每当一个计数器出现在屏幕上时，它的 state 会被创建出来。每当它被移除时，它的 state 就会被销毁。在它们之间切换会一次又一次地使它们的 state 重置。需要强调的是：key 不是全局唯一的，它们只能指定其在父组件内部的顺序，为 React 确定同一位置组件提供辅助信息。 总结组件间共享状态可以通过“状态提升”将需要共享的状态放至最近的公共父组件中，再通过 props 传递给子组件；如果要改变状态，还可以将父组件的状态处理函数一同传递给子组件。此外，同一类型组件若在 UI 树中的相同位置被多次渲染，其状态会得到相应的保留，如果两个条件不满足任何一个，都会使得状态被刷新。","link":"/2024/03/framworks/front_framworks/react/share-states-in-components/"},{"title":"React UI 中的声明式思维","text":"声明式的考虑UI声明式UI意味着不必直接启用、关闭、显示或隐藏组件，而是只需要 声明你想要显示的内容， React 就会通过计算得出该如何去更新 UI。在 React 中，可以通过如下步骤思考如何实现UI效果： 定位组件中不同的视图状态 确定是什么触发了这些 state 的改变 表示内存中的 state（需要使用 useState） 删除任何不必要的 state 变量 连接事件处理函数去设置 state 定位组件中不同的视图状态可视化 UI 界面中用户可能看到的所有不同的“状态”，例如： 无数据：表单有一个不可用状态的“提交”按钮。 输入中：表单有一个可用状态的“提交”按钮。 提交中：表单完全处于不可用状态，加载动画出现。 成功时：显示“成功”的消息而非表单。 错误时：与输入状态类似，但会多错误的消息。 在添加逻辑之前去“模拟”不同的状态或创建“模拟状态”，这个过程可在书写逻辑前快速迭代 UI。官网示例代码如下： 表单布局12345678910111213141516171819202122export default function Form({ status = 'empty'}) { if (status === 'success') { return &lt;h1&gt;That's right!&lt;/h1&gt; } return ( &lt;&gt; &lt;h2&gt;City quiz&lt;/h2&gt; &lt;p&gt; In which city is there a billboard that turns air into drinkable water? &lt;/p&gt; &lt;form&gt; &lt;textarea /&gt; &lt;br /&gt; &lt;button&gt; Submit &lt;/button&gt; &lt;/form&gt; &lt;/&gt; )} 确定是什么触发了这些状态的改变触发 state 的更新来响应两种输入： 人为输入。比如点击按钮、在表单中输入内容，或导航到链接。 计算机输入。比如网络请求得到反馈、定时器被触发，或加载一张图片。 以上两种情况中，必须设置 state 变量 去更新 UI。对于正在开发中的表单来说，需要改变 state 以响应几个不同的输入： 改变输入框中的文本时（人为）应该根据输入框的内容是否是空值，从而决定将表单的状态从空值状态切换到输入中或切换回原状态。 点击提交按钮时（人为）应该将表单的状态切换到提交中的状态。 网络请求成功后（计算机）应该将表单的状态切换到成功的状态。 网络请求失败后（计算机）应该将表单的状态切换到失败的状态，与此同时，显示错误信息。 可通过如下表示方法，对状态变化进行可视化： 通过 useState 表示内存中的 state接下来需要在内存中通过 useState表示组件中的视图状态。诀窍很简单：state 的每个部分都是“处于变化中的”，并且让“变化的部分”尽可能的少。根据上一部分的状态图，需要存储输入的 answer 以及用于存储最后一个错误的 error，这是必须的两个状态。除此之外，一开始可以添加足够多的 state 开始，确保所有可能的视图状态都囊括其中： 表单状态12345678910// 必须状态const [answer, setAnswer] = useState(''); const [error, setError] = useState(null);// 其余状态const [isEmpty, setIsEmpty] = useState(true); const [isTyping, setIsTyping] = useState(false); const [isSubmitting, setIsSubmitting] = useState(false); const [isSuccess, setIsSuccess] = useState(false); const [isError, setIsError] = useState(false); 删除任何不必要的 state 变量为避免 state 内容中的重复，从而只需要关注那些必要的部分，可以对前一步中的状态进行重构。这可以让组件更容易被理解，减少重复并且避免歧义，同时防止出现在内存中的 state 不代表任何你希望用户看到的有效 UI 的情况。可以通过如下一些问题促进对状态的思考： 这个 state 是否会导致矛盾？例如，isTyping 与 isSubmitting 的状态不能同时为 true。矛盾的产生通常说明了这个 state 没有足够的约束条件。两个布尔值有四种可能的组合，但是只有三种对应有效的状态。为了将“不可能”的状态移除，可以将 'typing'、'submitting' 以及 'success' 这三个中的其中一个与 status 结合。 相同的信息是否已经在另一个 state 变量中存在？另一个矛盾：isEmpty 和 isTyping 不能同时为 true。通过使它们成为独立的 state 变量，可能会导致它们不同步并导致 bug。幸运的是，可以移除 isEmpty 转而用 message.length === 0。 是否可以通过另一个 state 变量的相反值得到相同的信息？isError 是多余的，因为可以检查 error !== null。 重构完成以后，剩下三个必要的状态： 精简后的表单状态123const [answer, setAnswer] = useState(''); const [error, setError] = useState(null); const [status, setStatus] = useState('typing'); // 'typing', 'submitting', or 'success' 连接事件处理函数以设置 state最后，创建事件处理函数以设置 state 变量。下面是绑定好事件的最终表单： 绑定事件处理函数后的表单示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import { useState } from 'react';export default function Form() { const [answer, setAnswer] = useState(''); const [error, setError] = useState(null); const [status, setStatus] = useState('typing'); if (status === 'success') { return &lt;h1&gt;That's right!&lt;/h1&gt; } async function handleSubmit(e) { e.preventDefault(); setStatus('submitting'); try { await submitForm(answer); setStatus('success'); } catch (err) { setStatus('typing'); setError(err); } } function handleTextareaChange(e) { setAnswer(e.target.value); } return ( &lt;&gt; &lt;h2&gt;City quiz&lt;/h2&gt; &lt;p&gt; In which city is there a billboard that turns air into drinkable water? &lt;/p&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;textarea value={answer} onChange={handleTextareaChange} disabled={status === 'submitting'} /&gt; &lt;br /&gt; &lt;button disabled={ answer.length === 0 || status === 'submitting' }&gt; Submit &lt;/button&gt; {error !== null &amp;&amp; &lt;p className=&quot;Error&quot;&gt; {error.message} &lt;/p&gt; } &lt;/form&gt; &lt;/&gt; );}function submitForm(answer) { // Pretend it's hitting the network. return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { let shouldError = answer.toLowerCase() !== 'lima' if (shouldError) { reject(new Error('Good guess but a wrong answer. Try again!')); } else { resolve(); } }, 1500); });} 总结总的来说，在 React 中，可从 UI 整体出发，为每个视图状态先声明 UI。在组件开发过程中，列出所有状态及其转换关系，通过 useState 将状态放置于组件内，在移除冗余状态后，利用设值函数及事件处理函数，根据事件结果调整状态变化。","link":"/2024/03/framworks/front_framworks/react/thinking-in-declarative-ui/"}],"tags":[{"name":"容器化","slug":"容器化","link":"/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"前端框架","slug":"前端框架","link":"/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"categories":[{"name":"容器化","slug":"容器化","link":"/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"Docker","slug":"容器化/Docker","link":"/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/Docker/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"前端框架","slug":"框架/前端框架","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"React","slug":"框架/前端框架/React","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/"}],"pages":[]}